<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>喜马拉雅Java实习</title>
      <link href="/post/8943.html"/>
      <url>/post/8943.html</url>
      
        <content type="html"><![CDATA[<h1 id="喜马拉雅Java实习"><a href="#喜马拉雅Java实习" class="headerlink" title="喜马拉雅Java实习"></a>喜马拉雅Java实习</h1><h3 id="1-Java语言，常用的集合类"><a href="#1-Java语言，常用的集合类" class="headerlink" title="1.Java语言，常用的集合类"></a>1.Java语言，常用的集合类</h3><blockquote><ol><li><strong>List（列表）</strong>：<ul><li><code>ArrayList</code>: 基于动态数组实现的List，查询快，增删慢，线程不安全但效率高。</li><li><code>LinkedList</code>: 双向链表实现的List，对于频繁的插入删除操作效率较高，同时支持双端操作。</li><li><code>Vector</code>: 和ArrayList类似，但是线程安全的，但由于同步机制，性能相对较低。</li></ul></li><li><strong>Set（集合）</strong>:<ul><li><code>HashSet</code>: 无序，不允许重复元素，基于哈希表实现。</li><li><code>LinkedHashSet</code>: 维持元素插入顺序，不允许重复元素。</li><li><code>TreeSet</code>: 自然排序或自定义比较器排序的Set，不允许重复元素。</li></ul></li><li><strong>Map（映射）</strong>：<ul><li><code>HashMap</code>: 键值对存储，无序，允许键值对存在，基于哈希表实现。</li><li><code>LinkedHashMap</code>: 维持插入顺序或者最近最少使用（LRU）顺序的Map。</li><li><code>TreeMap</code>: 键值对按自然排序或自定义比较器排序的Map。</li></ul></li><li><strong>Queue（队列）</strong>：<ul><li><code>LinkedList</code>（作为Queue使用时）: 实现FIFO（先进先出）队列。</li><li><code>PriorityQueue</code>: 支持优先级排序的队列。</li><li><code>ConcurrentLinkedQueue</code>: 线程安全的无界队列，基于链接节点实现。</li></ul></li><li><strong>Deque（双端队列）</strong>：<ul><li><code>ArrayDeque</code>: 双端队列，高效且线程不安全。</li><li><code>LinkedBlockingDeque</code>: 线程安全的双端阻塞队列。</li></ul></li><li><strong>Stack（栈）</strong>：<ul><li><code>Stack</code>: 类似于Vector的后进先出（LIFO）堆栈，虽然现在较少直接使用，但在一些旧代码或教学场景中仍然可见。</li></ul></li></ol><p>Java集合框架还包含其他辅助类和接口，比如<code>Collections</code>工具类，以及并发集合类如<code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code>等，它们针对多线程环境进行了优化设计。随着JDK版本的更新，集合框架还在不断扩充和完善以适应新的需求。</p></blockquote><h3 id="2-java线程池，什么时候会考虑使用，然后线程池的基本实现原理是什么"><a href="#2-java线程池，什么时候会考虑使用，然后线程池的基本实现原理是什么" class="headerlink" title="2.java线程池，什么时候会考虑使用，然后线程池的基本实现原理是什么"></a>2.java线程池，什么时候会考虑使用，然后线程池的基本实现原理是什么</h3><blockquote><p>在Java编程中，我们会考虑使用线程池的情况主要包括以下几点：</p><ol><li><strong>重复使用线程资源</strong>：如果你的应用程序中经常需要创建和销毁线程，这会导致较大的系统开销，因为线程创建和销毁的成本很高。线程池可以预先创建一组可复用的线程，当有任务提交时，可以从池中获取空闲线程来执行任务，而不是每次都创建新线程。</li><li><strong>控制并发级别</strong>：通过线程池可以方便地控制并发执行的任务数量，防止过多线程消耗系统资源导致性能下降或资源耗尽。</li><li><strong>任务队列管理</strong>：线程池内置了任务队列，可以有效管理待执行的任务，如FIFO、优先级队列等策略。</li><li><strong>异常处理和资源清理</strong>：线程池可以集中处理线程执行任务时可能出现的异常，以及任务完成后线程资源的回收和再利用。</li><li><strong>线程生命周期管理</strong>：线程池可以更好地管理和控制线程的生命周期，例如设置线程最大闲置时间、最大线程数量等。</li></ol></blockquote><blockquote><p>线程池的基本实现原理大致如下：</p><p>在Java中，线程池的核心实现是<code>java.util.concurrent.ThreadPoolExecutor</code>类，它的工作原理概括如下：</p><ul><li><strong>核心组件</strong>：线程池包含核心线程数、最大线程数、任务队列（BlockingQueue）、线程工厂（ThreadFactory）以及拒绝策略（RejectedExecutionHandler）等核心组件。</li><li><strong>任务提交</strong>：当调用<code>execute()</code>方法提交任务时，线程池首先检查核心线程是否都在工作。如果没有空闲核心线程且任务队列未满，则创建一个新的核心线程来执行任务；若核心线程已满且任务队列未满，则将任务放入队列中等待执行；若队列已满且线程数未达到最大值，则创建一个非核心线程来执行任务；若线程数已达到最大值且无法将任务放入队列，则根据拒绝策略处理任务。</li><li><strong>线程执行</strong>：线程池中的工作线程不断地从任务队列中取出任务执行，一旦任务执行完毕，线程会再次尝试从队列中获取下一个任务。</li><li><strong>线程回收</strong>：线程执行完任务后并不立即销毁，而是继续等待队列中的任务，或者在满足一定条件（如超过闲置时间）后终止。</li><li><strong>线程池关闭</strong>：可以通过调用<code>shutdown()</code>或<code>shutdownNow()</code>方法来关闭线程池，前者会等待所有已提交的任务执行完毕后关闭线程池，后者会尝试中断所有正在执行的任务并关闭线程池。</li></ul></blockquote><h3 id="3-java常用的锁，以乐观锁和悲观锁出发，举具体例子和他们的区别"><a href="#3-java常用的锁，以乐观锁和悲观锁出发，举具体例子和他们的区别" class="headerlink" title="3.java常用的锁，以乐观锁和悲观锁出发，举具体例子和他们的区别"></a>3.java常用的锁，以乐观锁和悲观锁出发，举具体例子和他们的区别</h3><p>Java中，乐观锁和悲观锁是两种并发控制策略，分别适用于不同的场景。</p><blockquote><p><strong>悲观锁（Pessimistic Locking）</strong>： 悲观锁假定每一次对共享资源的访问都会造成冲突，所以在访问数据前会先获取锁，确保在锁释放之前，同一资源的其他访问都被阻塞。在Java中，<code>synchronized</code>关键字是最典型的悲观锁实现方式。下面是一个简单的示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (balance &gt;= amount) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         balance -= amount;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Insufficient balance&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>withdraw</code>方法被<code>synchronized</code>修饰，这意味着在同一时间只有一个线程可以进入这个方法，执行账户扣款操作。其他线程试图调用此方法时会被阻塞，直到第一个线程执行完毕并释放锁。</p></blockquote><blockquote><p><strong>乐观锁（Optimistic Locking）</strong>： 乐观锁假定大部分时候不会有并发冲突，只有在更新数据时才会检测是否有其他线程在此期间修改了数据。乐观锁在Java中常通过CAS（Compare and Set）操作实现，如使用<code>java.util.concurrent.atomic</code>包中的原子类。下面是一个使用乐观锁的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptimisticAccount</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">balance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">     <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">currentBalance</span> <span class="operator">=</span> balance.get();</span><br><span class="line">         <span class="keyword">if</span> (currentBalance &lt; amount) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不足扣款，直接返回失败</span></span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 使用CAS操作尝试更新余额</span></span><br><span class="line">         <span class="keyword">if</span> (balance.compareAndSet(currentBalance, currentBalance - amount)) &#123;</span><br><span class="line">             <span class="comment">// 更新成功，退出循环</span></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用了<code>AtomicInteger</code>代替普通整数变量来存储账户余额。<code>compareAndSet</code>方法会在更新前先比较当前值是否是我们期望的值，如果是则更新，如果不是则说明有其他线程已经修改了余额，此次更新操作失败，然后循环重试。</p></blockquote><blockquote><p><strong>区别</strong>：</p><ul><li>悲观锁：在操作数据前先获取锁，确保操作期间数据不受干扰，但可能导致更多的线程阻塞和上下文切换。</li><li>乐观锁：在操作数据时不预先加锁，仅在更新时检查数据是否有冲突，减少了锁的争用和上下文切换，但如果并发冲突高，可能会导致大量的重试。</li></ul><p>在实际应用中，选择哪种锁取决于并发场景的具体特点和需求，如数据的并发更新频率、锁的粒度等因素。</p></blockquote><h3 id="4-spring中常用的一些注解"><a href="#4-spring中常用的一些注解" class="headerlink" title="4.spring中常用的一些注解"></a>4.spring中常用的一些注解</h3><blockquote><p>Spring框架中有很多注解，以下是其中一些非常常用的注解及其功能：</p><ol><li><strong><code>@Component</code></strong><ul><li>用于标记一个类为Spring容器中的组件，Spring会自动扫描并将其作为Bean进行管理。它是所有受Spring管理组件的基本注解，衍生出了<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code>等更具体的注解。</li></ul></li><li><strong><code>@Service</code></strong><ul><li>通常应用于业务逻辑层的服务类上，表明此类是一个业务逻辑组件，其功能与<code>@Component</code>相同，但提供了更好的语义，方便团队阅读代码时快速识别。</li></ul></li><li><strong><code>@Repository</code></strong><ul><li>用于标记持久层的类，如DAO（Data Access Object）接口或实现类，它除了具备<code>@Component</code>的功能外，还可以让Spring为其提供特殊的异常转换机制，将特定的数据访问异常转换成Spring DataAccessException体系的异常。</li></ul></li><li><strong><code>@Controller</code></strong><ul><li>在Spring MVC中，用于标记Web控制器类，这类类通常包含处理HTTP请求的方法，并通过视图解析器返回视图或直接响应HTTP请求结果。</li></ul></li><li><strong><code>@Autowired</code></strong><ul><li>用于自动装配Bean，Spring容器会自动根据类型或名称（配合<code>@Qualifier</code>使用）注入相应的依赖。它可以应用于字段、setter方法或构造函数上。</li></ul></li><li><strong><code>@Required</code></strong><ul><li>用于标记bean的setter方法，表明该方法对应的属性在配置时必须被设置，否则Spring容器在初始化bean时会抛出异常。</li></ul></li><li><strong><code>@RequestMapping</code></strong><ul><li>在Spring MVC中，用于映射HTTP请求到处理方法上，可以定义请求的URI、HTTP方法等。</li></ul></li><li><strong><code>@PathVariable</code></strong><ul><li>用于方法参数中，提取URI模板中的变量值。</li></ul></li><li><strong><code>@RequestParam</code></strong><ul><li>用于方法参数中，绑定HTTP请求参数。</li></ul></li><li><strong><code>@Qualifier</code></strong><ul><li>用于解决同一个类型的多个Bean注入时的选择问题，通过指定名称来区分。</li></ul></li><li><strong><code>@PostConstruct</code> 和 <code>@PreDestroy</code></strong><ul><li>分别用于生命周期回调方法，前者在依赖注入完成后、初始化方法之前执行，后者在销毁Bean之前执行。</li></ul></li><li><strong><code>@Configuration</code></strong><ul><li>用于标记类为配置类，这样的类可以包含<code>@Bean</code>注解的方法，用来替代XML配置。</li></ul></li><li><strong><code>@Bean</code></strong><ul><li>用于配置类的方法上，声明该方法产生的对象是一个Spring容器管理的Bean。</li></ul></li><li><strong><code>@Transactional</code></strong><ul><li>用于表示一个方法或类具有事务性，Spring会为此方法开启、管理和关闭事务。</li></ul></li></ol><p>以上这些注解都是Spring框架中常见的用于组件扫描、依赖注入、AOP切面编程、事务管理以及Spring MVC中的HTTP请求处理等方面的注解。</p></blockquote><h3 id="5-feign远程调用的流程"><a href="#5-feign远程调用的流程" class="headerlink" title="5.feign远程调用的流程"></a>5.feign远程调用的流程</h3><blockquote><p>Feign是一个Java框架，用于简化HTTP API客户端的编写，它使得调用远程服务就像调用本地方法一样。以下是Feign进行远程调用的大致流程：</p><ol><li><p><strong>定义接口与注解</strong> 开发人员首先创建一个接口，并在接口方法上使用Feign提供的注解（如<code>@RequestLine</code>、<code>@Headers</code>等）来定义HTTP请求的URL、HTTP方法、请求头及参数映射。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;microservice-name&quot;, url = &quot;http://example.com/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ClientInterface</span> &#123;</span><br><span class="line">    <span class="meta">@RequestLine(&quot;GET /users/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">getUser</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> String id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建Feign实例</strong> Spring Cloud环境中，当应用启动时，会通过<code>@FeignClient</code>注解自动创建Feign客户端实例，这个实例代理了我们定义的接口。</p></li><li><p><strong>发起远程调用</strong> 在业务逻辑中注入并使用上述定义的接口，调用接口方法时，比如<code>getUser(String id)</code>，实际上是在调用Feign代理的方法。</p></li><li><p><strong>构建HTTP请求</strong> Feign通过反射和注解处理器分析接口方法的注解信息，根据这些信息构建出一个HTTP请求，包括URL、HTTP方法、请求头和参数。</p></li><li><p><strong>编码请求体（如果有）</strong> 如果方法参数需要作为请求体发送，Feign会使用Encoder对请求体进行序列化。</p></li><li><p><strong>发送HTTP请求</strong> 请求通过HTTP客户端（默认是Apache HttpClient或OkHttp）发送到远程服务。</p></li><li><p><strong>接收并解析HTTP响应</strong> 服务端处理请求并返回响应。Feign客户端接收到HTTP响应后，使用Decoder对响应体进行反序列化，将HTTP响应转换为Java对象。</p></li><li><p><strong>返回结果</strong> 解析后的Java对象作为方法调用的结果返回给业务逻辑。</p></li><li><p><strong>异常处理</strong> 如果远程调用过程中出现网络错误、超时或其他异常，Feign会抛出相应的异常，供调用方捕获处理。</p></li></ol><p>需要注意的是，Feign内部还集成了Ribbon等组件，可以实现客户端负载均衡和服务发现功能。在实际使用中，Feign极大地简化了微服务间的HTTP调用过程，提升了开发效率。</p></blockquote><h3 id="6-mysql索引类型有哪些，一般用哪些"><a href="#6-mysql索引类型有哪些，一般用哪些" class="headerlink" title="6.mysql索引类型有哪些，一般用哪些"></a>6.mysql索引类型有哪些，一般用哪些</h3><blockquote><p>MySQL数据库中常见的索引类型主要包括以下几种：</p><ol><li><strong>普通索引</strong>（Normal Index）<ul><li>最基本的索引类型，仅仅为了加快查询速度，没有任何附加的限制。</li><li>创建语法：<code>CREATE INDEX idx_name ON table_name(column_name);</code></li></ul></li><li><strong>唯一索引</strong>（Unique Index）<ul><li>除了加速查询外，还确保索引列的每一行的值都是唯一的，但允许有一个空值（NULL）。</li><li>创建语法：<code>CREATE UNIQUE INDEX idx_unique ON table_name(column_name);</code></li></ul></li><li><strong>主键索引</strong>（Primary Key Index）<ul><li>是一种特殊的唯一索引，用于标识表中的每一行记录，不允许有重复值也不允许有NULL值。</li><li>当你在创建表时声明列为主键（<code>PRIMARY KEY</code>），MySQL会自动为此列创建主键索引。</li><li>创建语法：在创建表时直接指定<code>PRIMARY KEY (column_name)</code>。</li></ul></li><li><strong>组合索引</strong>（Composite&#x2F;Index&#x2F;Multi-Column Index）<ul><li>对表中的多个列同时创建索引，它的效率特别体现在查询条件中包含了这些列的联合条件时。</li><li>创建语法：<code>CREATE INDEX idx_composite ON table_name(column1, column2, ...);</code></li></ul></li><li><strong>全文索引</strong>（Full-Text Index）<ul><li>用于对文本类型的列进行全文本搜索，特别适合在大文本字段中查找包含特定单词或短语的行。</li><li>仅在MyISAM和InnoDB存储引擎中支持，且对全文索引的创建和查询语法有所不同。</li><li>创建语法：<code>CREATE FULLTEXT INDEX idx_fulltext ON table_name(column_name);</code></li></ul></li></ol><p>在实际应用中，根据业务需求和查询模式选择合适的索引类型非常重要。通常：</p><ul><li>对于经常出现在WHERE子句中并且用于过滤的列，创建普通索引或唯一索引。</li><li>如果列的值必须唯一（如身份证号、邮箱地址等），创建唯一索引。</li><li>对于表的主键列，创建主键索引。</li><li>当查询涉及多个列，并且这些列一起出现时效率最高，可以考虑创建组合索引。</li><li>如果需要对文本内容进行全文本搜索，使用全文索引。</li></ul><p>在大多数OLTP系统中，普通索引、唯一索引和主键索引最为常见和广泛使用。全文索引则更多地出现在对文本内容有搜索需求的场景。</p></blockquote><h3 id="7-布隆过滤器原理"><a href="#7-布隆过滤器原理" class="headerlink" title="7.布隆过滤器原理"></a>7.布隆过滤器原理</h3><blockquote><p>布隆过滤器（Bloom Filter）是一种空间效率极高的概率型数据结构，用于判断一个元素是否可能存在于一个集合中，但它不能百分之百保证判断的准确性，有可能会有误判（False Positive）的情况，但绝对不会漏判（False Negative），即如果布隆过滤器说一个元素不在集合中，则这个元素肯定不在集合内；如果它说可能在集合中，则元素可能真的在也可能不在集合中。</p><p>布隆过滤器的原理如下：</p><ol><li>初始化阶段： 创建一个固定长度的二进制向量（位数组），所有的位初始化为0。</li><li>插入元素： 当插入一个元素时，使用预先设定好的多个独立的哈希函数对元素进行运算，每个哈希函数都会映射到位数组的一个位置。对于每个哈希函数的输出，对应位数组的位置置为1。</li><li>查询元素： 当查询一个元素是否存在时，同样使用相同的哈希函数对该元素进行哈希运算，查看位数组中这些哈希函数对应的位置是否全为1。如果有一个位为0，则该元素肯定不在集合中；如果全为1，则认为元素可能在集合中（存在误判可能性）。</li></ol><p>由于哈希函数的碰撞，当多个不同的元素经过哈希运算后可能会落在位数组的同一位置，这就导致了误判的存在。随着越来越多的元素插入，误判率会逐渐增大。布隆过滤器的设计需要在误判率和存储空间之间做出折衷，通过调整位数组大小和哈希函数的数量来控制这种平衡。</p></blockquote><h3 id="8-布隆过滤器的误判率估算"><a href="#8-布隆过滤器的误判率估算" class="headerlink" title="8.布隆过滤器的误判率估算"></a>8.布隆过滤器的误判率估算</h3><blockquote><p>布隆过滤器的误判率（False Positive Rate，FPR）可以通过数学模型进行估算。误判率主要受到以下几个因素的影响：</p><ol><li><strong>位数组（Bit Array）的长度 m</strong>：布隆过滤器的基础是位数组，其长度m决定了可以存储的哈希值的空间。</li><li><strong>哈希函数的数量 k</strong>：用于映射元素到位数组的不同位置的独立且均匀分布的哈希函数个数。</li><li><strong>预计插入的元素数量 n</strong>：预估要加入布隆过滤器的元素总数。</li></ol><p>误判率的估算公式基于概率统计，其中一个重要公式是：</p><p>​                                                                    <strong>FPR</strong>≈(1−<em>e</em>−<em>kn</em>&#x2F;<em>m</em>)<strong>k</strong></p><p>随着m（位数组长度）的增加，或k（哈希函数数量）的增加，误判率会降低。但增大m或k也会相应地增加存储空间需求和计算成本。</p><p>为了在误判率和存储空间之间找到最佳平衡，可以反过来通过已知的误判率要求和预计插入元素数量n来计算所需的位数组长度m和哈希函数数量k。</p><p>实践中，布隆过滤器的大小和哈希函数的选择常常依据预设的误判率阈值和预期插入的元素数量进行设计和调整。在设计布隆过滤器时，通常会使用已有的公式和经验法则来确定适当的参数m和k。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
            <tag> 喜马拉雅 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾迅后台一面</title>
      <link href="/post/48c2.html"/>
      <url>/post/48c2.html</url>
      
        <content type="html"><![CDATA[<h1 id="腾迅后台开发一面"><a href="#腾迅后台开发一面" class="headerlink" title="腾迅后台开发一面"></a>腾迅后台开发一面</h1><h3 id="1-讲一下TCP三次握手，为什么要三次，两次或者四次不行吗"><a href="#1-讲一下TCP三次握手，为什么要三次，两次或者四次不行吗" class="headerlink" title="1.讲一下TCP三次握手，为什么要三次，两次或者四次不行吗"></a>1.讲一下TCP三次握手，为什么要三次，两次或者四次不行吗</h3><blockquote><p>TCP建立连接时，通过三次握手能<strong>防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按需传输。</p><p>不使用<strong>两次握手</strong>和<strong>四次握手</strong>的原因：</p><ul><li>两次握手：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li><li>四次握手：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数；</li></ul></blockquote><h3 id="2-讲一下常见的针对TCP的网络攻击？如何应对SYN-flood攻击？"><a href="#2-讲一下常见的针对TCP的网络攻击？如何应对SYN-flood攻击？" class="headerlink" title="2.讲一下常见的针对TCP的网络攻击？如何应对SYN flood攻击？"></a>2.讲一下常见的针对TCP的网络攻击？如何应对SYN flood攻击？</h3><blockquote><p><strong>常见的针对TCP的网络攻击</strong></p><ul><li><strong>SYN Flood攻击</strong>：这是一种利用TCP协议握手过程中的缺陷进行的攻击。攻击者发送大量的TCP SYN请求到目标服务器，但在收到服务器的SYN+ACK响应后并不发送最后的ACK确认，导致服务器上留下大量等待完成的半开连接，耗尽服务器资源，使得正常的TCP连接无法建立。</li><li><strong>TCP回话劫持</strong>：这种攻击方式是通过窃取TCP会话中的序列号等信息，然后冒充合法用户接入到会话中。攻击者可以监听网络上的TCP会话，分析并预测序列号，然后发送伪造的数据包，中断或篡改原有的会话内容。</li><li><strong>TCP重置攻击</strong>：在这种攻击中，攻击者发送伪造的TCP RST（重置）数据包到目标主机，中断正常的TCP连接。由于TCP协议的设计，当接收到RST数据包时，连接的两端都会关闭连接，这使得攻击者可以成功地中断服务或进行拒绝服务攻击。</li></ul></blockquote><blockquote><p><strong>如何应对SYN flood攻击？</strong></p><ol><li>启用SYN Cookie技术：SYN Cookie是一种无状态的TCP连接技术，它通过计算一个独特的Cookie来验证TCP连接的合法性，而不需要在服务器上保存每个连接的状态信息。当服务器收到SYN请求时，它会计算一个Cookie并发送给客户端，客户端在后续的ACK报文中携带该Cookie，服务器通过验证Cookie的有效性来判断连接是否合法。这样可以有效减少服务器资源的消耗，并防止SYN Flood攻击导致的资源耗尽。</li><li>调整TCP协议栈参数：通过调整TCP协议栈的参数，可以优化服务器的性能和防御SYN Flood攻击。例如，可以减小SYN Timeout时间，使服务器更快地释放无效的链接请求；增大TCP连接的队列长度，提高服务器处理连接请求的能力；启用TCP Fast Open等特性，加快TCP连接的建立过程。</li><li>使用防火墙或入侵检测系统（IDS）：防火墙或IDS可以监控网络流量，并识别出异常的SYN请求流量。它们可以根据预设的规则对恶意流量进行过滤或限制，从而保护服务器免受SYN Flood攻击的侵害。</li></ol></blockquote><h3 id="3-讲一下TCP的TIME-WAIT状态，如果服务器中存在大量的这个状态应该怎么排查？"><a href="#3-讲一下TCP的TIME-WAIT状态，如果服务器中存在大量的这个状态应该怎么排查？" class="headerlink" title="3.讲一下TCP的TIME_WAIT状态，如果服务器中存在大量的这个状态应该怎么排查？"></a>3.讲一下TCP的TIME_WAIT状态，如果服务器中存在大量的这个状态应该怎么排查？</h3><blockquote><p><strong>介绍TIME_WAIT状态</strong>：当TCP连接的一方（通常是客户端）主动关闭连接时，会发送一个FIN包给对方，表示希望关闭连接。服务端通常会回一个ACK确认包。当服务端也完成发送后，会再次发送一个FIN包给客户端，此时客户端接收到FIN后会回复一个ACK给服务端，之后客户端会进入TIME_WAIT状态。在TIME_WAIT状态下，连接会保持一段时间（通常是2MSL，即最大报文段生存时间的两倍），以确保在网络中延迟的数据包能够被正确处理。</p><p><img src="https://cdn.jsdelivr.net/gh/mrxmxm/blog-img/blog-imgD2B5CA33BD970F64A6301FA75AE2EB22.png"></p></blockquote><blockquote><p><strong>如何排查TIME_WAIT</strong></p><ol><li><p><strong>确认TIME_WAIT状态的数量</strong>： 使用<code>netstat</code>命令来查看当前TCP连接的状态分布。例如，运行<code>netstat -nat | grep TIME_WAIT | wc -l</code>可以查看TIME_WAIT状态的连接数。</p></li><li><p><strong>查看系统TCP参数</strong>： 使用<code>sysctl -a | grep tcp</code>命令可以查看系统中与TCP相关的内核参数设置，特别关注<code>net.ipv4.tcp_tw_reuse</code>、<code>net.ipv4.tcp_tw_recycle</code>（在某些情况下可能不推荐启用）和<code>net.ipv4.tcp_fin_timeout</code>等参数的设置。</p></li><li><p><strong>分析网络连接和应用程序行为</strong>： 确定哪些应用程序或服务正在产生大量的TIME_WAIT连接。使用<code>netstat -natp</code>可以查看每个连接的进程ID和程序名称。</p></li><li><p><strong>检查网络问题和延迟</strong>： 网络问题或延迟可能导致连接不能正常关闭，从而产生大量的TIME_WAIT状态。使用网络诊断工具（如<code>ping</code>、<code>traceroute</code>等）来检查网络状况。</p></li></ol></blockquote><h3 id="4-如果项目中出现CPU占用过高的情况，该怎么排查和处理？"><a href="#4-如果项目中出现CPU占用过高的情况，该怎么排查和处理？" class="headerlink" title="4.如果项目中出现CPU占用过高的情况，该怎么排查和处理？"></a>4.如果项目中出现CPU占用过高的情况，该怎么排查和处理？</h3><blockquote><p>在Linux环境下，项目出现CPU占用过高的情况时，可以按照以下步骤进行排查和处理：</p><ol><li><strong>定位高CPU占用的进程</strong>：<ul><li>使用<code>top</code>命令查看系统中CPU占用率最高的进程。</li></ul></li><li><strong>分析进程中的线程</strong>：<ul><li>如果发现某个进程的CPU占用率特别高，可以使用<code>top -H -p [PID]</code>来查看该进程中各个线程的CPU占用情况。</li><li>找出占用CPU最高的线程ID。</li></ul></li><li><strong>转换线程ID为16进制</strong>：<ul><li>使用<code>printf &quot;%x\n&quot; [线程ID]</code>命令将线程ID转换为16进制格式。</li></ul></li><li><strong>获取线程堆栈信息</strong>：<ul><li>使用<code>jstack [进程PID] | grep [线程ID的16进制] -A 30</code>命令获取该线程的Java堆栈信息（如果是Java进程）。这可以帮助定位到具体的代码行或方法调用。</li><li>如果不是Java进程，可以使用<code>gdb</code>或其他相应的调试工具来获取线程的堆栈信息。</li></ul></li><li><strong>分析代码和日志</strong>：<ul><li>根据堆栈信息，检查相关的代码逻辑，看是否有死循环、资源泄露、复杂计算等导致CPU占用过高的问题。</li><li>同时检查应用程序的日志，看是否有异常或错误信息与高CPU占用相关。</li></ul></li><li><strong>处理措施</strong>：<ul><li>如果是代码问题，修复相应的bug或优化算法。</li><li>如果是配置问题，调整系统或应用程序的配置参数。</li><li>如果是资源不足，考虑增加硬件资源或优化资源分配。</li><li>如果是外部攻击，加强系统的安全防护措施。</li></ul></li></ol></blockquote><h3 id="5-介绍一下Linux常见命令？top命令具体是做什么的？"><a href="#5-介绍一下Linux常见命令？top命令具体是做什么的？" class="headerlink" title="5.介绍一下Linux常见命令？top命令具体是做什么的？"></a>5.介绍一下Linux常见命令？top命令具体是做什么的？</h3><blockquote><p>大家记忆一些，根据记忆回答就行，例如</p><ul><li><strong>chmod</strong>：更改文件或目录的权限。</li><li><strong>cat</strong>：查看文件内容。</li></ul></blockquote><blockquote><p><strong>top命令具体是做什么的？</strong> top命令，它是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况.该命令可以提供实时的对系统处理器的状态监视，它会显示系统中CPU最“敏感”的任务列表，并且可以按CPU使用、内存使用和执行时间对任务进行排序。</p></blockquote><h3 id="6-讲一下HashMap，为什么HashMap要引入红黑树？为什么树化的默认节点是8？如果不用红黑树如何处理过长的链表？"><a href="#6-讲一下HashMap，为什么HashMap要引入红黑树？为什么树化的默认节点是8？如果不用红黑树如何处理过长的链表？" class="headerlink" title="6.讲一下HashMap，为什么HashMap要引入红黑树？为什么树化的默认节点是8？如果不用红黑树如何处理过长的链表？"></a>6.讲一下HashMap，为什么HashMap要引入红黑树？为什么树化的默认节点是8？如果不用红黑树如何处理过长的链表？</h3><blockquote><p><strong>为什么HashMap要引入红黑树？</strong> 引入之前，当发生哈希冲突时，数据是以链表的形式进行存储的，如果冲突严重，链表就会过长，链表O（N）的复杂度性能太差。用红黑树期望是把复杂度降到<strong>O（log n）</strong></p></blockquote><blockquote><p>红黑树中的TreeNode是链表中的Node所占空间的2倍，虽然红黑树的查找效率为o(logN)，要优于链表的o(N)，但是当链表长度比较小的时候，即使全部遍历，时间复杂度也不会太高。固，要寻找一种时间和空间的平衡，即在链表长度达到一个阈值之后再转换为红黑树。 之所以是8，是因为Java的源码贡献者在进行大量实验发现，hash碰撞发生8次的概率已经降低到了0.00000006，几乎为不可能事件，如果真的碰撞发生了8次，那么这个时候说明由于元素本身和hash函数的原因，此时的链表性能已经已经很差了，操作的hash碰撞的可能性非常大了，后序可能还会继续发生hash碰撞。所以，在这种极端的情况下才会把链表转换为红黑树.</p></blockquote><blockquote><p><strong>如果不用红黑树如何处理过长的链表？</strong></p><ul><li><strong>使用其他数据结构</strong>:除了红黑树之外，还可以考虑使用其他数据结构来优化长链表的问题。例如，可以使用平衡树（如 AVL 树）、B树或B+树等。这些数据结构都可以在 O(log n) 的时间复杂度内完成查找、插入和删除操作.</li></ul></blockquote><h3 id="7-HashMap是线程安全的吗？如果不是那什么是？为什么ConcurrentHashMap是线程安全的？是如何实现线程安全的呢？"><a href="#7-HashMap是线程安全的吗？如果不是那什么是？为什么ConcurrentHashMap是线程安全的？是如何实现线程安全的呢？" class="headerlink" title="7.HashMap是线程安全的吗？如果不是那什么是？为什么ConcurrentHashMap是线程安全的？是如何实现线程安全的呢？"></a>7.HashMap是线程安全的吗？如果不是那什么是？为什么ConcurrentHashMap是线程安全的？是如何实现线程安全的呢？</h3><p><strong>解析：</strong>： 面试常见套路，先问HashMap 再 问 ConcurrentHashMap。 关于线程安全的实现，一般会结合JDK1.7和JDK1.8一起来回答，当然也可以只回答JDK1.8,如果面试官问到1.7你再回答。所以需要两个版本一起掌握.</p><blockquote><p>HashMap 不是现成安全的，需要保证现成安全的话，推荐使用ConcurrentHashMap。</p></blockquote><blockquote><p><strong>如何实现线程安全的？</strong></p><ul><li><strong>JDK 1.7</strong>中的<strong>ConcurrentHashMap</strong>通过分段锁（<strong>Segmentation</strong>）实现线程安全。它将整个哈希表分成多个段（<strong>Segment</strong>），每个段都是一个小的哈希表，并且拥有自己的锁。这样，多个线程可以并发地访问不同的段，从而减少了锁的竞争，提高了并发性能。</li><li><strong>JDK 1.8</strong>中的<strong>ConcurrentHashMap</strong>则采用了完全不同的设计。它摒弃了分段锁的概念，转而使用了一种更细粒度的锁策略，结合<strong>CAS（Compare-and-Swap）</strong>无锁算法来实现线程安全。在<strong>JDK 1.8</strong>中，<strong>ConcurrentHashMap</strong>将整个哈希表看作一个整体，不再进行分段。而是通过<strong>数组+链表+红黑树</strong>的结构来存储数据，并使用<strong>Synchronized和CAS</strong>来协调并发访问。</li></ul></blockquote><h3 id="8-介绍一下Base64编码的原理，为什么Base64编码会使数据体积变大33-？"><a href="#8-介绍一下Base64编码的原理，为什么Base64编码会使数据体积变大33-？" class="headerlink" title="8.介绍一下Base64编码的原理，为什么Base64编码会使数据体积变大33%？"></a>8.介绍一下Base64编码的原理，为什么Base64编码会使数据体积变大33%？</h3><blockquote><p><strong>Base64编码是</strong>:一种基于64个可打印字符来表示二进制数据的方法。其编码原理是将一个8位字节序列拆散为6位的片段，并为每个6位的片段分配一个字符，这64个字符包括小写字母a-z、大写字母A-Z、数字0-9、符号”+”和”&#x2F;“。实际上，还有一个垫字符”&#x3D;”，用于编码后的数据长度不是4的倍数时进行填充，因此严格来说有65个字符。</p></blockquote><blockquote><p><strong>Base64编码会使数据体积变大33%左右的原因</strong>:在于其编码方式。原始的二进制数据是按照8位一个字节进行存储的，而Base64编码将其拆分为6位一组，并用一个字符表示。这样，原本3个字节（24位）的数据被编码成了4个字符（每个字符8位，共32位）。因此，编码后的数据长度大约是原始数据长度的4&#x2F;3，即增加了约33%。</p></blockquote><h3 id="9-为什么Redis-Pub-Sub比Kafka更快一些？二者之间如何选取？"><a href="#9-为什么Redis-Pub-Sub比Kafka更快一些？二者之间如何选取？" class="headerlink" title="9.为什么Redis Pub&#x2F;Sub比Kafka更快一些？二者之间如何选取？"></a>9.为什么Redis Pub&#x2F;Sub比Kafka更快一些？二者之间如何选取？</h3><p><strong>解析：</strong>频率一般，推荐掌握。重在理解redis本身特点和Kafka的实现原理。然后推导回答，不要背。</p><blockquote><p><strong>为什么Redis Pub&#x2F;Sub比Kafka更快一些？</strong> Redis是一个内存数据库，其Pub&#x2F;Sub功能将消息保存在内存中。由于内存访问速度通常远快于磁盘访问速度，因此Redis在处理实时性较高的消息推送时具有优势。此外，Redis的Pub&#x2F;Sub模型相对简单，使得它在处理发布和订阅操作时的开销较小。 然而，Kafka是一个完整的系统，提供了高吞吐量、分布式的提交日志。它旨在处理大规模数据流，具有强大的持久化能力和容错性。Kafka的分布式架构和分区机制使得它能够在多个消费者之间实现负载均衡，从而提高整体处理能力。</p></blockquote><blockquote><p><strong>二者之间如何选取？</strong></p><p><strong>Redis PUB&#x2F;SUB使用场景：</strong></p><ol><li>消息持久性需求不高</li><li>吞吐量要求不高</li><li>可以忍受数据丢失</li><li>数据量不大</li></ol><p><strong>Kafka使用场景：</strong>(上面以外的其他场景)</p><ol><li>高可靠性</li><li>高吞吐量</li><li>持久性高</li><li>多样化的消费处理模型</li></ol></blockquote><h3 id="9-Kafka是如何做到数据持久化的？"><a href="#9-Kafka是如何做到数据持久化的？" class="headerlink" title="9.Kafka是如何做到数据持久化的？"></a>9.Kafka是如何做到数据持久化的？</h3><p><strong>解析：</strong>Kafka相关高频面试题，Kafka重要原理知识点之一，推荐掌握</p><blockquote><ol><li><p>Kafka把Topic中一个Partition大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完成的文件，减少磁盘占用</p></li><li><p>通过索引信息可以快速定位Message和确定response的最大大小</p></li><li><p>通过将索引元数据全部映射到 memory，可以避免 Segment 文件的磁盘I&#x2F;O操作</p></li><li><p>通过索引文件稀疏存储，可以大幅降低索引文件元数据占用空间大小</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 腾讯 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客部署</title>
      <link href="/post/9365.html"/>
      <url>/post/9365.html</url>
      
        <content type="html"><![CDATA[<h2 id="测试是否能否显示文字"><a href="#测试是否能否显示文字" class="headerlink" title="测试是否能否显示文字"></a>测试是否能否显示文字</h2><p><img src="https://cdn.jsdelivr.net/gh/tianzhijiaozi123/blog-img/blog-img89b21dc8-9be9-466e-a4b0-5759a7897f76-1709370908863.png"></p><h4 id="兔子和小狗"><a href="#兔子和小狗" class="headerlink" title="兔子和小狗"></a>兔子和小狗</h4><p><img src="https://cdn.jsdelivr.net/gh/tianzhijiaozi123/blog-img/blog-imgdog-rabbit.png"></p><h2 id="部署流程"><a href="#部署流程" class="headerlink" title="部署流程"></a>部署流程</h2><h3 id="文章发布"><a href="#文章发布" class="headerlink" title="文章发布"></a>文章发布</h3><blockquote><p>进入 <strong>F:\Blog\source_posts</strong> 文件夹，然后右键 <strong>git bash</strong> ，再输入命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npx hexo new post &quot;新建博客文件名&quot;</span><br></pre></td></tr></table></figure><p>之后就在该文件夹中生成一个新的md文件，就可以在该文件中书写博客了，每次写完博客要上传部署时，输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npx hexo cl   #清空缓存</span><br><span class="line">npx hexo g    #上传静态文件</span><br><span class="line">npx hexo s    #进行保存，然后就可以在本地访问了</span><br><span class="line"># 最后就是上传部署</span><br><span class="line">npx hexo d</span><br></pre></td></tr></table></figure></blockquote><h3 id="更新配置"><a href="#更新配置" class="headerlink" title="更新配置"></a>更新配置</h3><p>更新hexo配置一般在**_config.yml<strong>文件中，更新</strong>butterfly<strong>主题配置在</strong>_config.butterfly.yml**文件中</p><p>主题中相关图片背景的地址放在<strong>F:\Blog\themes\butterfly\source\img</strong>文件夹下，在该文件夹下进行图片更换</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
            <tag> Hexo </tag>
            
            <tag> 主题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/3eeb.html"/>
      <url>/post/3eeb.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p>上传新的图片</p><p><img src="https://st.tencent-cloud.com/qb/tool/images/fa45a96f-cad1-4a5d-a426-678e85662f57.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
            <tag> 主题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
