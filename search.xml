<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>百度后端实习</title>
      <link href="/post/78d7.html"/>
      <url>/post/78d7.html</url>
      
        <content type="html"><![CDATA[<h1 id="百度后端实习"><a href="#百度后端实习" class="headerlink" title="百度后端实习"></a>百度后端实习</h1><h3 id="1-联合索引底层存储结构（和其他类型的索引的存储结构有什么区别）"><a href="#1-联合索引底层存储结构（和其他类型的索引的存储结构有什么区别）" class="headerlink" title="1.联合索引底层存储结构（和其他类型的索引的存储结构有什么区别）"></a>1.联合索引底层存储结构（和其他类型的索引的存储结构有什么区别）</h3><p>联合索引是数据库中一种常见的索引类型，它允许在多个列上创建索引，以提高查询性能。与单列索引相比，联合索引的底层存储结构有一些区别，主要体现在如何组织和存储索引数据的方式上。</p><blockquote><p><strong>存储数据的组织方式</strong>：</p><ul><li>单列索引：单列索引只包含一个列的值和指向相应数据行的指针。通常，单列索引按照列值的大小顺序来组织存储数据。</li><li>联合索引：联合索引则包含多个列的值，以及指向相应数据行的指针。联合索引可以按照多个列值的组合来组织存储数据，这意味着可以根据多个列的值来定位数据行。</li></ul><p><strong>查询时的性能影响</strong>：</p><ul><li>单列索引：单列索引适合用于只涉及单个列的查询。当查询条件涉及到索引列时，数据库可以更快地定位到匹配的数据行。</li><li>联合索引：联合索引适合用于涉及多个列的查询。当查询涉及到联合索引中的多个列时，数据库可以利用索引中列值的组合来快速定位匹配的数据行。</li></ul><p><strong>索引维护的复杂性</strong>：</p><ul><li>单列索引：单列索引的维护相对简单，因为它只需要维护单个列的值和指针。</li><li>联合索引：联合索引的维护相对复杂一些，因为它需要考虑多个列值的组合。当表中的数据发生变化时，数据库需要确保联合索引中的多个列值的组合保持有序，这可能需要更多的资源和时间。</li></ul></blockquote><p>联合索引在适当的情况下可以提供更好的查询性能，特别是对于涉及到联合索引中列值的组合的查询。然而，需要注意的是，联合索引的创建和维护可能会带来一些额外的开销，并且需要根据具体的查询需求和数据模式来合理选择索引策略。</p><h3 id="2-联合索引的叶子结点存的什么内容？"><a href="#2-联合索引的叶子结点存的什么内容？" class="headerlink" title="2.联合索引的叶子结点存的什么内容？"></a>2.联合索引的叶子结点存的什么内容？</h3><blockquote><p>联合索引的叶子节点存储的是索引列的值以及指向对应数据行的指针（聚集索引键值）。在联合索引中，叶子节点包含了多个列的值，以及指向对应数据行的指针（者聚集索引键值）的组合。</p><p>具体来说，叶子节点中存储了索引列的实际值，以及一个指向相应数据行的指针（者聚集索引键值）。这样，当数据库引擎根据联合索引执行查询时，它可以通过索引中的列值找到对应的叶子节点，然后使用叶子节点中的指针（键值）来定位到相应的数据行。</p><p>联合索引的叶子节点存储了索引列的值和指向数据行的指针（键值）的组合，这样可以在查询时快速定位到匹配的数据行。</p></blockquote><h3 id="3-事务会不会自动提交？"><a href="#3-事务会不会自动提交？" class="headerlink" title="3.事务会不会自动提交？"></a>3.事务会不会自动提交？</h3><blockquote><p>MySQL <strong>默认开启事务自动提交模式</strong>，即除非显式的开启事务（BEGIN 或 START TRANSACTION），否则每条 SOL 语句都会被当做一个单独的事务自动执行。</p><p>要启用自动提交，在执行任何DML（Data Manipulation Language）语句（例如INSERT、UPDATE、DELETE）之前，可以使用以下语句开启自动提交：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>或者可以在连接到数据库时在连接字符串中指定<code>autocommit</code>参数为1。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>u username <span class="operator">-</span>p <span class="operator">-</span>h hostname dbname <span class="comment">--autocommit=1</span></span><br></pre></td></tr></table></figure><p>这将使得MySQL会话处于自动提交模式，这意味着每个单独的DML语句都将自动成为一个事务，并在执行完成后立即提交。</p><p>如果想要禁用自动提交，可以使用以下语句：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>或者在连接字符串中指定<code>autocommit</code>参数为0。</p></blockquote><h3 id="4-MySQL默认的隔离级别是什么？"><a href="#4-MySQL默认的隔离级别是什么？" class="headerlink" title="4.MySQL默认的隔离级别是什么？"></a>4.MySQL默认的隔离级别是什么？</h3><blockquote><p>MySQL的默认隔离级别是<strong>可重复读（Repeatable Read）</strong>。在可重复读隔离级别下，事务可以读取其他事务已经提交的数据，但是不会看到其他事务未提交的数据。这意味着在同一个事务中多次读取相同的数据，将会得到相同的结果，即使其他事务对该数据进行了修改也是如此。</p><p>可重复读隔离级别保证了在同一个事务中多次读取数据时的一致性，但也可能导致一些并发问题，如幻读（Phantom Read）。MySQL提供了其他隔离级别来解决不同的并发问题，包括读未提交（Read Uncommitted）、读已提交（Read Committed）和串行化（Serializable）等。</p><p>需要注意的是，虽然MySQL的默认隔离级别是可重复读，但实际上可以在会话级别或全局级别进行更改，以满足特定的应用需求。</p><p>InnoDB 当前读下的幻读是通过**间隙锁（gap_lock)**来实现的。在事务A查询的时候，会锁住一个间隙，其它事务往这个间隙插入、删除等操作都是会被锁阻塞的。间隙锁和插入意向锁互斥，彻底解决了当前读下的幻读问题。</p><p>但是InnoDB 没有完全解决快照读下的幻读问题。</p></blockquote><h3 id="5-GC算法有哪些？"><a href="#5-GC算法有哪些？" class="headerlink" title="5.GC算法有哪些？"></a>5.GC算法有哪些？</h3><p>Java的垃圾收集（Garbage Collection，GC）算法有多种，每种算法都有其独特的特点和适用场景。以下是几种常见的Java GC算法：</p><blockquote><ol><li><strong>标记-清除算法（Mark and Sweep）</strong>：<ul><li>标记阶段：从根对象出发，递归地标记所有可以被访问到的对象。</li><li>清除阶段：清除未被标记的对象，即不可达对象。</li><li>缺点：产生内存碎片，可能导致内存分配效率降低。</li></ul></li><li><strong>复制算法（Copying）</strong>：<ul><li>将堆内存分为两个区域：年轻代和老年代。</li><li>年轻代分为Eden区和两个Survivor区。</li><li>对象首先被分配到Eden区，当Eden区满时，触发Minor GC，将存活的对象复制到Survivor区，然后清空Eden区和一个Survivor区，再将存活的对象从另一个Survivor区复制到空的Survivor区。</li><li>优点：不会产生内存碎片，适用于频繁回收对象的场景。</li></ul></li><li><strong>标记-整理算法（Mark and Compact）</strong>：<ul><li>标记阶段：与标记-清除算法相同，标记所有可达对象。</li><li>整理阶段：将所有存活的对象向一端移动，然后清理掉不可达对象，从而消除内存碎片。</li><li>优点：不会产生内存碎片，可以提高内存分配效率。</li></ul></li><li><strong>分代收集算法（Generational Collection）</strong>：<ul><li>将堆内存分为年轻代和老年代两部分，使用不同的GC算法。</li><li>年轻代通常使用复制算法，因为大多数对象在这里很快变得不可达，适合频繁进行垃圾收集。</li><li>老年代通常使用标记-清除或标记-整理算法，因为老年代存活的对象较多，适合采用更加成熟的算法来进行垃圾收集。</li></ul></li><li><strong>G1算法（Garbage-First）</strong>：<ul><li>将堆内存分成多个大小相等的区域（Region），包括年轻代、老年代和Metaspace等。</li><li>将整个堆内存划分为多个Region，通过标记-复制和标记-整理的方式来执行垃圾收集。</li><li>G1算法通过优先收集垃圾最多的Region来提高垃圾收集效率，因此称为“Garbage-First”。</li></ul></li></ol></blockquote><h3 id="6-G1垃圾回收器了解吗？"><a href="#6-G1垃圾回收器了解吗？" class="headerlink" title="6.G1垃圾回收器了解吗？"></a>6.G1垃圾回收器了解吗？</h3><p><strong>G1（Garbage-First）垃圾回收器</strong>是Java虚拟机（JVM）中一种现代的垃圾回收器，引入自Java 7 Update 4版本。G1垃圾回收器旨在替代<strong>CMS（Concurrent Mark-Sweep）垃圾回收器</strong>，并且在大内存堆上表现更加稳定和高效。</p><blockquote><p>G1垃圾回收器具有以下特点：</p><ol><li><strong>区域化内存管理</strong>：G1将堆内存划分为多个固定大小的区域（Region），每个区域可以是Eden区、Survivor区或Old区。这种区域化的内存管理有助于更好地控制垃圾回收过程，减少停顿时间。</li><li><strong>分代收集</strong>：虽然G1并不是一个传统的分代收集器，但它仍然将堆内存划分为年轻代和老年代，并且使用不同的垃圾回收策略来处理这两个代。</li><li><strong>并发标记清除</strong>：G1使用了并发标记（Concurrent Marking）来减少垃圾回收暂停时间。在标记阶段，G1通过并发标记线程来标记活动对象，而在应用程序运行的同时，也会继续标记操作。这样可以减少标记阶段对应用程序的影响。</li><li><strong>整理内存</strong>：G1使用了复制算法来清理内存，不再使用传统的压缩算法。在垃圾收集过程中，G1会选择一些区域进行垃圾收集，并将存活对象复制到其他区域中，从而实现内存的整理和碎片整理。</li><li><strong>垃圾优先收集</strong>：G1根据垃圾回收需求来选择优先回收的区域，以此来提高垃圾回收效率。它会优先选择包含垃圾最多的区域进行回收，从而最大程度地减少垃圾对象。</li></ol><p><strong>G1垃圾回收器在大内存堆上表现更加稳定和高效，尤其适用于需要低停顿时间和更加可控的垃圾回收的应用场景。</strong></p></blockquote><h3 id="7-什么时候会触发GC？"><a href="#7-什么时候会触发GC？" class="headerlink" title="7.什么时候会触发GC？"></a>7.什么时候会触发GC？</h3><blockquote><p>在Java虚拟机中，垃圾回收（GC）会在以下几种情况下触发：</p><ol><li><strong>系统内存不足</strong>：当Java虚拟机检测到系统内存不足时，会触发垃圾回收来释放内存空间，以确保应用程序的正常运行。这通常是通过监视堆内存的使用情况来检测的。</li><li><strong>调用System.gc()方法</strong>：虽然调用System.gc()方法并不会立即触发垃圾回收，但它会向Java虚拟机发出建议性的垃圾回收请求。Java虚拟机可以选择是否立即响应这个请求。</li><li><strong>长时间停顿</strong>：当应用程序执行时间较长，而且没有进行垃圾回收时，Java虚拟机可能会为了避免堆内存耗尽而触发垃圾回收。这种情况下，垃圾回收通常会引起一段较长的停顿时间，称为<strong>Full GC</strong>。</li><li><strong>Young Generation满</strong>：在分代垃圾回收器中，当Young Generation区域满时，会触发一次<strong>Minor GC</strong>。这会导致Eden区和Survivor区的垃圾回收。</li><li><strong>Old Generation满</strong>：如果Old Generation区域满了，会触发一次<strong>Major GC（也称为Full GC）</strong>。这种情况下，整个堆内存都会进行垃圾回收。</li><li><strong>永久代&#x2F;元空间满</strong>：对于HotSpot虚拟机，如果永久代（Java 7之前）或者元空间（Java 8及之后）满了，会触发一次垃圾回收。这种情况下，垃圾回收主要针对类的元数据和常量池。</li></ol><p>需要注意的是，具体触发垃圾回收的时机和方式取决于<strong>Java虚拟机的实现</strong>，不同的虚拟机可能有不同的行为。此外，开发人员可以通过<strong>调整垃圾回收相关的参数</strong>来影响垃圾回收的行为，以优化应用程序的性能和资源利用率。</p></blockquote><h3 id="8-线程安全和线程不安全是什么意思？"><a href="#8-线程安全和线程不安全是什么意思？" class="headerlink" title="8.线程安全和线程不安全是什么意思？"></a>8.线程安全和线程不安全是什么意思？</h3><blockquote><p>“<strong>线程安全</strong>“和”<strong>线程不安全</strong>“是描述在多线程环境中并发操作的状态的术语。</p><ol><li><strong>线程安全</strong>：<ul><li>线程安全指的是在<strong>多线程环境</strong>下，对<strong>共享数据的访问操作</strong>能够保证在并发情况下不会导致<strong>数据的不一致性或损坏</strong>。一个线程安全的操作或数据结构能够在<strong>并发访问时维持其内部状态的一致性</strong>。</li><li>线程安全的实现通常会采用<strong>同步机制</strong>（例如<strong>锁、信号量</strong>等）来保护共享资源的访问，以确保在任意时刻<strong>只有一个线程能够访问共享资源</strong>，从而避免竞态条件（Race Condition）和其他并发问题。</li></ul></li><li><strong>线程不安全</strong>：<ul><li>线程不安全指的是在多线程环境下，对<strong>共享数据的访问操作</strong>可能会导致<strong>数据的不一致性或损坏</strong>。线程不安全的操作或数据结构在并发访问时无法保证其<strong>内部状态的一致性</strong>，可能会导致意外的结果或程序错误。</li><li>线程不安全的实现通常没有考虑到并发访问的情况，没有采取适当的同步措施来保护共享资源的访问，因此可能会出现竞态条件和其他并发问题。</li></ul></li></ol><p>举例来说，如果多个线程同时尝试向同一个数组中添加元素，而该数组的添加操作没有进行适当的同步控制，那么就可能导致线程不安全的情况，如数据覆盖、越界访问等。为了保证线程安全，需要在并发访问共享资源时使用适当的同步机制来确保数据的一致性。</p></blockquote><h3 id="9-场景-有一个-key-对应的-value-是一个json-结构，json-当中有好几个子任务，这些子任务如果对-key-进行修改的话-会不会存在线程安全的问题-如何解决-如果是多个节点的情况，应该怎么加锁"><a href="#9-场景-有一个-key-对应的-value-是一个json-结构，json-当中有好几个子任务，这些子任务如果对-key-进行修改的话-会不会存在线程安全的问题-如何解决-如果是多个节点的情况，应该怎么加锁" class="headerlink" title="9.场景:有一个 key 对应的 value 是一个json,结构，json,当中有好几个子任务，这些子任务如果对 key 进行修改的话,会不会存在线程安全的问题?如何解决?如果是多个节点的情况，应该怎么加锁?"></a>9.场景:有一个 key 对应的 value 是一个json,结构，json,当中有好几个子任务，这些子任务如果对 key 进行修改的话,会不会存在线程安全的问题?如何解决?如果是多个节点的情况，应该怎么加锁?</h3><p>在这个场景中，如果多个线程同时对同一个 key 对应的 JSON 结构中的子任务进行修改，就有可能出现线程安全的问题，因为多个线程同时对同一个数据结构进行修改可能导致数据不一致或损坏。</p><blockquote><p>要解决这个问题，可以采用以下方法：</p><ol><li><strong>使用线程安全的数据结构</strong>：可以选择使用线程安全的数据结构来存储 JSON 数据，例如 <code>ConcurrentHashMap</code> 或 <code>CopyOnWriteArrayList</code>，它们内部提供了并发访问的安全保证，能够在多线程环境下安全地进行操作。</li><li><strong>使用同步机制</strong>：可以使用同步机制（例如锁）来保护对 JSON 数据的修改操作，确保在任意时刻只有一个线程能够修改数据。比如，在对 JSON 数据进行修改之前，先获取一个锁，并在操作完成后释放锁。</li><li><strong>粒度控制</strong>：可以考虑将 JSON 数据的不同部分分别进行锁定，以减小锁的粒度，提高并发性能。比如，可以为不同的子任务或不同的节点设置不同的锁。</li></ol><p>如果是多个节点的情况，需要在分布式环境下进行考虑。可以选择分布式锁机制来实现跨节点的数据同步和并发控制，比如使用 <strong>ZooKeeper</strong>、<strong>Redis</strong> 等分布式系统提供的分布式锁服务来确保在不同节点上对数据的并发修改操作是安全的。</p></blockquote><h3 id="10-Setnx-知道吗-用这个加锁有什么问题吗-怎么解决"><a href="#10-Setnx-知道吗-用这个加锁有什么问题吗-怎么解决" class="headerlink" title="10.Setnx,知道吗? 用这个加锁有什么问题吗?怎么解决?"></a>10.Setnx,知道吗? 用这个加锁有什么问题吗?怎么解决?</h3><blockquote><p><code>SETNX</code> 是 Redis 中的一个命令，用于设置键的值，但仅当键不存在时才设置成功。在分布式环境中，可以利用 <code>SETNX</code> 命令来实现分布式锁。具体步骤如下：</p><ol><li>客户端通过 <code>SETNX</code> 命令尝试将一个特定的键作为锁的标识，并设置一个唯一的值作为锁的持有者标识。</li><li>如果 <code>SETNX</code> 命令成功执行（返回值为 1），表示当前客户端成功获取了锁，可以执行后续操作。</li><li>如果 <code>SETNX</code> 命令执行失败（返回值为 0），表示当前锁已被其他客户端持有，当前客户端未获取到锁，需要等待一段时间后重新尝试获取锁。</li></ol></blockquote><blockquote><p>虽然 <code>SETNX</code> 命令在某些情况下可以用来实现简单的分布式锁，但是它也存在一些问题：</p><ol><li><strong>无法设置过期时间</strong>：<code>SETNX</code> 命令本身不支持设置键的过期时间，因此当持有锁的客户端发生异常或程序出现问题时，可能导致锁无法被释放，造成死锁或锁泄露问题。</li><li><strong>非原子性操作</strong>：尽管 <code>SETNX</code> 命令本身是原子性的，但是获取锁和释放锁通常需要多个命令的组合，例如获取锁时需要执行 <code>SETNX</code>，释放锁时需要执行 <code>DEL</code>。这种组合操作不是原子性的，可能会导致锁的不一致性问题。</li></ol></blockquote><blockquote><p>为了解决这些问题，可以采用以下方法：</p><ol><li><strong>配合 <code>EXPIRE</code> 命令设置过期时间</strong>：在获取锁成功后，使用 <code>EXPIRE</code> 命令为锁设置一个合理的过期时间，确保即使持有锁的客户端发生异常，锁也能在一定时间后自动释放。</li><li><strong>使用 Lua 脚本确保原子性</strong>：将获取锁和释放锁的操作封装在 Lua 脚本中执行，Lua 脚本可以在 Redis 中以原子性的方式执行多个命令，确保获取锁和释放锁的操作是原子性的，避免了竞态条件的发生。</li><li><strong>考虑使用 Redlock 算法等更复杂的分布式锁方案</strong>：如果应用场景要求更高的分布式锁安全性和可靠性，可以考虑使用 Redlock 算法等更复杂的分布式锁方案，这些方案通常基于多个 Redis 实例，并结合超时机制和复制机制来保证分布式锁的安全性和可靠性。</li></ol></blockquote><h3 id="11-层次遍历一个-DAG-图，有向无环图。"><a href="#11-层次遍历一个-DAG-图，有向无环图。" class="headerlink" title="11.层次遍历一个 DAG 图，有向无环图。"></a>11.层次遍历一个 DAG 图，有向无环图。</h3><p>以下是用 Java 实现层次遍历（BFS）一个有向无环图（DAG）的代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopologicalSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">topologicalSort</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (numCourses &lt;= <span class="number">0</span> || prerequisites == <span class="literal">null</span> || prerequisites.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建入度数组和邻接表</span></span><br><span class="line">        <span class="type">int</span>[] indegree = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; adjacencyList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            adjacencyList.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建入度数组和邻接表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] prerequisite : prerequisites) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">course</span> <span class="operator">=</span> prerequisite[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">prerequisiteCourse</span> <span class="operator">=</span> prerequisite[<span class="number">1</span>];</span><br><span class="line">            indegree[course]++;</span><br><span class="line">            adjacencyList.get(prerequisiteCourse).add(course);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用队列进行拓扑排序</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">course</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            result.add(course);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> neighbor : adjacencyList.get(course)) &#123;</span><br><span class="line">                indegree[neighbor]--;</span><br><span class="line">                <span class="keyword">if</span> (indegree[neighbor] == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.offer(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有环，则无法完成拓扑排序</span></span><br><span class="line">        <span class="keyword">if</span> (result.size() != numCourses) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numCourses</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        <span class="type">int</span>[][] prerequisites = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">2</span>, <span class="number">0</span>&#125;, &#123;<span class="number">3</span>, <span class="number">1</span>&#125;, &#123;<span class="number">3</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">        <span class="type">TopologicalSort</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TopologicalSort</span>();</span><br><span class="line">        List&lt;Integer&gt; result = solution.topologicalSort(numCourses, prerequisites);</span><br><span class="line">        System.out.println(<span class="string">&quot;Topological order: &quot;</span> + result); <span class="comment">// Output: [0, 1, 2, 3]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，定了一个 <code>TopologicalSort</code> 类，其中包含 <code>topologicalSort</code> 方法用于对有向无环图进行层次遍历（拓扑排序）。在 <code>topologicalSort</code> 方法中，我们首先构建了入度数组和邻接表，然后使用队列进行拓扑排序，并将排序结果保存在 <code>result</code> 中。最后，我们检查排序结果是否完整，如果存在环则返回空列表。</p><p>在 <code>main</code> 方法中，我们定义了一个示例的有向无环图，然后调用 <code>topologicalSort</code> 方法进行层次遍历，并输出排序结果。</p><h3 id="12-leetcode岛屿数量"><a href="#12-leetcode岛屿数量" class="headerlink" title="12.leetcode岛屿数量"></a>12.leetcode岛屿数量</h3><p>以下是用 Java 实现 LeetCode 上「岛屿数量」问题的代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumIslands</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">numIslands</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    numIslands++;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> numIslands;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= rows || j &lt; <span class="number">0</span> || j &gt;= cols || grid[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>; <span class="comment">// Mark the current cell as visited</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Explore the four neighboring cells</span></span><br><span class="line">        dfs(grid, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i, j - <span class="number">1</span>);</span><br><span class="line">        dfs(grid, i, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[][] grid = &#123;</span><br><span class="line">            &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">NumIslands</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumIslands</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">numIslands</span> <span class="operator">=</span> solution.numIslands(grid);</span><br><span class="line">        System.out.println(<span class="string">&quot;Number of islands: &quot;</span> + numIslands); <span class="comment">// Output: 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，定义了一个 <code>NumIslands</code> 类，其中包含 <code>numIslands</code> 方法用于计算岛屿数量。在 <code>numIslands</code> 方法中，我们使用深度优先搜索（DFS）来遍历二维网格，并统计岛屿的数量。具体的深度优先搜索逻辑由 <code>dfs</code> 方法实现。在 <code>main</code> 方法中，我们定义了一个示例的二维网格 <code>grid</code>，并调用 <code>numIslands</code> 方法计算岛屿数量。</p><h3 id="13-有一个主任务，它有四个子任务，分别存在下面几种状态-wait-running，success，fail。用if-else-的形式写出所有可能发生的情况。"><a href="#13-有一个主任务，它有四个子任务，分别存在下面几种状态-wait-running，success，fail。用if-else-的形式写出所有可能发生的情况。" class="headerlink" title="13.有一个主任务，它有四个子任务，分别存在下面几种状态:wait,running，success，fail。用if-else 的形式写出所有可能发生的情况。"></a>13.有一个主任务，它有四个子任务，分别存在下面几种状态:wait,running，success，fail。用if-else 的形式写出所有可能发生的情况。</h3><p>以下是使用 Java 实现主任务及其四个子任务可能的状态组合的代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainTask</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">mainTaskStatus</span> <span class="operator">=</span> <span class="string">&quot;wait&quot;</span>; <span class="comment">// 主任务状态</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">subTask1Status</span> <span class="operator">=</span> <span class="string">&quot;wait&quot;</span>; <span class="comment">// 子任务1状态</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">subTask2Status</span> <span class="operator">=</span> <span class="string">&quot;running&quot;</span>; <span class="comment">// 子任务2状态</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">subTask3Status</span> <span class="operator">=</span> <span class="string">&quot;success&quot;</span>; <span class="comment">// 子任务3状态</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">subTask4Status</span> <span class="operator">=</span> <span class="string">&quot;fail&quot;</span>; <span class="comment">// 子任务4状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mainTaskStatus.equals(<span class="string">&quot;wait&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (subTask1Status.equals(<span class="string">&quot;wait&quot;</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;主任务等待，子任务1等待&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subTask1Status.equals(<span class="string">&quot;running&quot;</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;主任务等待，子任务1运行中&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subTask1Status.equals(<span class="string">&quot;success&quot;</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;主任务等待，子任务1成功&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subTask1Status.equals(<span class="string">&quot;fail&quot;</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;主任务等待，子任务1失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mainTaskStatus.equals(<span class="string">&quot;running&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 类似处理其他状态组合...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mainTaskStatus.equals(<span class="string">&quot;success&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 类似处理其他状态组合...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mainTaskStatus.equals(<span class="string">&quot;fail&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 类似处理其他状态组合...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段 Java 代码中，定义了一个 <code>MainTask</code> 类，其中包含了 <code>main()</code> 方法作为程序入口。在 <code>main()</code> 方法中，定义了主任务和四个子任务的状态变量，并使用嵌套的 <code>if-else</code> 条件语句来处理不同的状态组合。根据实际需求，可以在每个条件分支中添加相应的逻辑处理。</p>]]></content>
      
      
      <categories>
          
          <category> Java面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
            <tag> 百度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>喜马拉雅Java实习</title>
      <link href="/post/8943.html"/>
      <url>/post/8943.html</url>
      
        <content type="html"><![CDATA[<h1 id="喜马拉雅Java实习"><a href="#喜马拉雅Java实习" class="headerlink" title="喜马拉雅Java实习"></a>喜马拉雅Java实习</h1><h3 id="1-Java语言，常用的集合类"><a href="#1-Java语言，常用的集合类" class="headerlink" title="1.Java语言，常用的集合类"></a>1.Java语言，常用的集合类</h3><blockquote><ol><li><strong>List（列表）</strong>：<ul><li><code>ArrayList</code>: 基于动态数组实现的List，查询快，增删慢，线程不安全但效率高。</li><li><code>LinkedList</code>: 双向链表实现的List，对于频繁的插入删除操作效率较高，同时支持双端操作。</li><li><code>Vector</code>: 和ArrayList类似，但是线程安全的，但由于同步机制，性能相对较低。</li></ul></li><li><strong>Set（集合）</strong>:<ul><li><code>HashSet</code>: 无序，不允许重复元素，基于哈希表实现。</li><li><code>LinkedHashSet</code>: 维持元素插入顺序，不允许重复元素。</li><li><code>TreeSet</code>: 自然排序或自定义比较器排序的Set，不允许重复元素。</li></ul></li><li><strong>Map（映射）</strong>：<ul><li><code>HashMap</code>: 键值对存储，无序，允许键值对存在，基于哈希表实现。</li><li><code>LinkedHashMap</code>: 维持插入顺序或者最近最少使用（LRU）顺序的Map。</li><li><code>TreeMap</code>: 键值对按自然排序或自定义比较器排序的Map。</li></ul></li><li><strong>Queue（队列）</strong>：<ul><li><code>LinkedList</code>（作为Queue使用时）: 实现FIFO（先进先出）队列。</li><li><code>PriorityQueue</code>: 支持优先级排序的队列。</li><li><code>ConcurrentLinkedQueue</code>: 线程安全的无界队列，基于链接节点实现。</li></ul></li><li><strong>Deque（双端队列）</strong>：<ul><li><code>ArrayDeque</code>: 双端队列，高效且线程不安全。</li><li><code>LinkedBlockingDeque</code>: 线程安全的双端阻塞队列。</li></ul></li><li><strong>Stack（栈）</strong>：<ul><li><code>Stack</code>: 类似于Vector的后进先出（LIFO）堆栈，虽然现在较少直接使用，但在一些旧代码或教学场景中仍然可见。</li></ul></li></ol><p>Java集合框架还包含其他辅助类和接口，比如<code>Collections</code>工具类，以及并发集合类如<code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code>等，它们针对多线程环境进行了优化设计。随着JDK版本的更新，集合框架还在不断扩充和完善以适应新的需求。</p></blockquote><h3 id="2-java线程池，什么时候会考虑使用，然后线程池的基本实现原理是什么"><a href="#2-java线程池，什么时候会考虑使用，然后线程池的基本实现原理是什么" class="headerlink" title="2.java线程池，什么时候会考虑使用，然后线程池的基本实现原理是什么"></a>2.java线程池，什么时候会考虑使用，然后线程池的基本实现原理是什么</h3><blockquote><p>在Java编程中，我们会考虑使用线程池的情况主要包括以下几点：</p><ol><li><strong>重复使用线程资源</strong>：如果你的应用程序中经常需要创建和销毁线程，这会导致较大的系统开销，因为线程创建和销毁的成本很高。线程池可以预先创建一组可复用的线程，当有任务提交时，可以从池中获取空闲线程来执行任务，而不是每次都创建新线程。</li><li><strong>控制并发级别</strong>：通过线程池可以方便地控制并发执行的任务数量，防止过多线程消耗系统资源导致性能下降或资源耗尽。</li><li><strong>任务队列管理</strong>：线程池内置了任务队列，可以有效管理待执行的任务，如FIFO、优先级队列等策略。</li><li><strong>异常处理和资源清理</strong>：线程池可以集中处理线程执行任务时可能出现的异常，以及任务完成后线程资源的回收和再利用。</li><li><strong>线程生命周期管理</strong>：线程池可以更好地管理和控制线程的生命周期，例如设置线程最大闲置时间、最大线程数量等。</li></ol></blockquote><blockquote><p>线程池的基本实现原理大致如下：</p><p>在Java中，线程池的核心实现是<code>java.util.concurrent.ThreadPoolExecutor</code>类，它的工作原理概括如下：</p><ul><li><strong>核心组件</strong>：线程池包含核心线程数、最大线程数、任务队列（BlockingQueue）、线程工厂（ThreadFactory）以及拒绝策略（RejectedExecutionHandler）等核心组件。</li><li><strong>任务提交</strong>：当调用<code>execute()</code>方法提交任务时，线程池首先检查核心线程是否都在工作。如果没有空闲核心线程且任务队列未满，则创建一个新的核心线程来执行任务；若核心线程已满且任务队列未满，则将任务放入队列中等待执行；若队列已满且线程数未达到最大值，则创建一个非核心线程来执行任务；若线程数已达到最大值且无法将任务放入队列，则根据拒绝策略处理任务。</li><li><strong>线程执行</strong>：线程池中的工作线程不断地从任务队列中取出任务执行，一旦任务执行完毕，线程会再次尝试从队列中获取下一个任务。</li><li><strong>线程回收</strong>：线程执行完任务后并不立即销毁，而是继续等待队列中的任务，或者在满足一定条件（如超过闲置时间）后终止。</li><li><strong>线程池关闭</strong>：可以通过调用<code>shutdown()</code>或<code>shutdownNow()</code>方法来关闭线程池，前者会等待所有已提交的任务执行完毕后关闭线程池，后者会尝试中断所有正在执行的任务并关闭线程池。</li></ul></blockquote><h3 id="3-java常用的锁，以乐观锁和悲观锁出发，举具体例子和他们的区别"><a href="#3-java常用的锁，以乐观锁和悲观锁出发，举具体例子和他们的区别" class="headerlink" title="3.java常用的锁，以乐观锁和悲观锁出发，举具体例子和他们的区别"></a>3.java常用的锁，以乐观锁和悲观锁出发，举具体例子和他们的区别</h3><p>Java中，乐观锁和悲观锁是两种并发控制策略，分别适用于不同的场景。</p><blockquote><p><strong>悲观锁（Pessimistic Locking）</strong>： 悲观锁假定每一次对共享资源的访问都会造成冲突，所以在访问数据前会先获取锁，确保在锁释放之前，同一资源的其他访问都被阻塞。在Java中，<code>synchronized</code>关键字是最典型的悲观锁实现方式。下面是一个简单的示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (balance &gt;= amount) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         balance -= amount;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Insufficient balance&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>withdraw</code>方法被<code>synchronized</code>修饰，这意味着在同一时间只有一个线程可以进入这个方法，执行账户扣款操作。其他线程试图调用此方法时会被阻塞，直到第一个线程执行完毕并释放锁。</p></blockquote><blockquote><p><strong>乐观锁（Optimistic Locking）</strong>： 乐观锁假定大部分时候不会有并发冲突，只有在更新数据时才会检测是否有其他线程在此期间修改了数据。乐观锁在Java中常通过CAS（Compare and Set）操作实现，如使用<code>java.util.concurrent.atomic</code>包中的原子类。下面是一个使用乐观锁的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptimisticAccount</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">balance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">     <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">currentBalance</span> <span class="operator">=</span> balance.get();</span><br><span class="line">         <span class="keyword">if</span> (currentBalance &lt; amount) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不足扣款，直接返回失败</span></span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 使用CAS操作尝试更新余额</span></span><br><span class="line">         <span class="keyword">if</span> (balance.compareAndSet(currentBalance, currentBalance - amount)) &#123;</span><br><span class="line">             <span class="comment">// 更新成功，退出循环</span></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用了<code>AtomicInteger</code>代替普通整数变量来存储账户余额。<code>compareAndSet</code>方法会在更新前先比较当前值是否是我们期望的值，如果是则更新，如果不是则说明有其他线程已经修改了余额，此次更新操作失败，然后循环重试。</p></blockquote><blockquote><p><strong>区别</strong>：</p><ul><li>悲观锁：在操作数据前先获取锁，确保操作期间数据不受干扰，但可能导致更多的线程阻塞和上下文切换。</li><li>乐观锁：在操作数据时不预先加锁，仅在更新时检查数据是否有冲突，减少了锁的争用和上下文切换，但如果并发冲突高，可能会导致大量的重试。</li></ul><p>在实际应用中，选择哪种锁取决于并发场景的具体特点和需求，如数据的并发更新频率、锁的粒度等因素。</p></blockquote><h3 id="4-spring中常用的一些注解"><a href="#4-spring中常用的一些注解" class="headerlink" title="4.spring中常用的一些注解"></a>4.spring中常用的一些注解</h3><blockquote><p>Spring框架中有很多注解，以下是其中一些非常常用的注解及其功能：</p><ol><li><strong><code>@Component</code></strong><ul><li>用于标记一个类为Spring容器中的组件，Spring会自动扫描并将其作为Bean进行管理。它是所有受Spring管理组件的基本注解，衍生出了<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code>等更具体的注解。</li></ul></li><li><strong><code>@Service</code></strong><ul><li>通常应用于业务逻辑层的服务类上，表明此类是一个业务逻辑组件，其功能与<code>@Component</code>相同，但提供了更好的语义，方便团队阅读代码时快速识别。</li></ul></li><li><strong><code>@Repository</code></strong><ul><li>用于标记持久层的类，如DAO（Data Access Object）接口或实现类，它除了具备<code>@Component</code>的功能外，还可以让Spring为其提供特殊的异常转换机制，将特定的数据访问异常转换成Spring DataAccessException体系的异常。</li></ul></li><li><strong><code>@Controller</code></strong><ul><li>在Spring MVC中，用于标记Web控制器类，这类类通常包含处理HTTP请求的方法，并通过视图解析器返回视图或直接响应HTTP请求结果。</li></ul></li><li><strong><code>@Autowired</code></strong><ul><li>用于自动装配Bean，Spring容器会自动根据类型或名称（配合<code>@Qualifier</code>使用）注入相应的依赖。它可以应用于字段、setter方法或构造函数上。</li></ul></li><li><strong><code>@Required</code></strong><ul><li>用于标记bean的setter方法，表明该方法对应的属性在配置时必须被设置，否则Spring容器在初始化bean时会抛出异常。</li></ul></li><li><strong><code>@RequestMapping</code></strong><ul><li>在Spring MVC中，用于映射HTTP请求到处理方法上，可以定义请求的URI、HTTP方法等。</li></ul></li><li><strong><code>@PathVariable</code></strong><ul><li>用于方法参数中，提取URI模板中的变量值。</li></ul></li><li><strong><code>@RequestParam</code></strong><ul><li>用于方法参数中，绑定HTTP请求参数。</li></ul></li><li><strong><code>@Qualifier</code></strong><ul><li>用于解决同一个类型的多个Bean注入时的选择问题，通过指定名称来区分。</li></ul></li><li><strong><code>@PostConstruct</code> 和 <code>@PreDestroy</code></strong><ul><li>分别用于生命周期回调方法，前者在依赖注入完成后、初始化方法之前执行，后者在销毁Bean之前执行。</li></ul></li><li><strong><code>@Configuration</code></strong><ul><li>用于标记类为配置类，这样的类可以包含<code>@Bean</code>注解的方法，用来替代XML配置。</li></ul></li><li><strong><code>@Bean</code></strong><ul><li>用于配置类的方法上，声明该方法产生的对象是一个Spring容器管理的Bean。</li></ul></li><li><strong><code>@Transactional</code></strong><ul><li>用于表示一个方法或类具有事务性，Spring会为此方法开启、管理和关闭事务。</li></ul></li></ol><p>以上这些注解都是Spring框架中常见的用于组件扫描、依赖注入、AOP切面编程、事务管理以及Spring MVC中的HTTP请求处理等方面的注解。</p></blockquote><h3 id="5-feign远程调用的流程"><a href="#5-feign远程调用的流程" class="headerlink" title="5.feign远程调用的流程"></a>5.feign远程调用的流程</h3><blockquote><p>Feign是一个Java框架，用于简化HTTP API客户端的编写，它使得调用远程服务就像调用本地方法一样。以下是Feign进行远程调用的大致流程：</p><ol><li><p><strong>定义接口与注解</strong> 开发人员首先创建一个接口，并在接口方法上使用Feign提供的注解（如<code>@RequestLine</code>、<code>@Headers</code>等）来定义HTTP请求的URL、HTTP方法、请求头及参数映射。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;microservice-name&quot;, url = &quot;http://example.com/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ClientInterface</span> &#123;</span><br><span class="line">    <span class="meta">@RequestLine(&quot;GET /users/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">getUser</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> String id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建Feign实例</strong> Spring Cloud环境中，当应用启动时，会通过<code>@FeignClient</code>注解自动创建Feign客户端实例，这个实例代理了我们定义的接口。</p></li><li><p><strong>发起远程调用</strong> 在业务逻辑中注入并使用上述定义的接口，调用接口方法时，比如<code>getUser(String id)</code>，实际上是在调用Feign代理的方法。</p></li><li><p><strong>构建HTTP请求</strong> Feign通过反射和注解处理器分析接口方法的注解信息，根据这些信息构建出一个HTTP请求，包括URL、HTTP方法、请求头和参数。</p></li><li><p><strong>编码请求体（如果有）</strong> 如果方法参数需要作为请求体发送，Feign会使用Encoder对请求体进行序列化。</p></li><li><p><strong>发送HTTP请求</strong> 请求通过HTTP客户端（默认是Apache HttpClient或OkHttp）发送到远程服务。</p></li><li><p><strong>接收并解析HTTP响应</strong> 服务端处理请求并返回响应。Feign客户端接收到HTTP响应后，使用Decoder对响应体进行反序列化，将HTTP响应转换为Java对象。</p></li><li><p><strong>返回结果</strong> 解析后的Java对象作为方法调用的结果返回给业务逻辑。</p></li><li><p><strong>异常处理</strong> 如果远程调用过程中出现网络错误、超时或其他异常，Feign会抛出相应的异常，供调用方捕获处理。</p></li></ol><p>需要注意的是，Feign内部还集成了Ribbon等组件，可以实现客户端负载均衡和服务发现功能。在实际使用中，Feign极大地简化了微服务间的HTTP调用过程，提升了开发效率。</p></blockquote><h3 id="6-mysql索引类型有哪些，一般用哪些"><a href="#6-mysql索引类型有哪些，一般用哪些" class="headerlink" title="6.mysql索引类型有哪些，一般用哪些"></a>6.mysql索引类型有哪些，一般用哪些</h3><blockquote><p>MySQL数据库中常见的索引类型主要包括以下几种：</p><ol><li><strong>普通索引</strong>（Normal Index）<ul><li>最基本的索引类型，仅仅为了加快查询速度，没有任何附加的限制。</li><li>创建语法：<code>CREATE INDEX idx_name ON table_name(column_name);</code></li></ul></li><li><strong>唯一索引</strong>（Unique Index）<ul><li>除了加速查询外，还确保索引列的每一行的值都是唯一的，但允许有一个空值（NULL）。</li><li>创建语法：<code>CREATE UNIQUE INDEX idx_unique ON table_name(column_name);</code></li></ul></li><li><strong>主键索引</strong>（Primary Key Index）<ul><li>是一种特殊的唯一索引，用于标识表中的每一行记录，不允许有重复值也不允许有NULL值。</li><li>当你在创建表时声明列为主键（<code>PRIMARY KEY</code>），MySQL会自动为此列创建主键索引。</li><li>创建语法：在创建表时直接指定<code>PRIMARY KEY (column_name)</code>。</li></ul></li><li><strong>组合索引</strong>（Composite&#x2F;Index&#x2F;Multi-Column Index）<ul><li>对表中的多个列同时创建索引，它的效率特别体现在查询条件中包含了这些列的联合条件时。</li><li>创建语法：<code>CREATE INDEX idx_composite ON table_name(column1, column2, ...);</code></li></ul></li><li><strong>全文索引</strong>（Full-Text Index）<ul><li>用于对文本类型的列进行全文本搜索，特别适合在大文本字段中查找包含特定单词或短语的行。</li><li>仅在MyISAM和InnoDB存储引擎中支持，且对全文索引的创建和查询语法有所不同。</li><li>创建语法：<code>CREATE FULLTEXT INDEX idx_fulltext ON table_name(column_name);</code></li></ul></li></ol><p>在实际应用中，根据业务需求和查询模式选择合适的索引类型非常重要。通常：</p><ul><li>对于经常出现在WHERE子句中并且用于过滤的列，创建普通索引或唯一索引。</li><li>如果列的值必须唯一（如身份证号、邮箱地址等），创建唯一索引。</li><li>对于表的主键列，创建主键索引。</li><li>当查询涉及多个列，并且这些列一起出现时效率最高，可以考虑创建组合索引。</li><li>如果需要对文本内容进行全文本搜索，使用全文索引。</li></ul><p>在大多数OLTP系统中，普通索引、唯一索引和主键索引最为常见和广泛使用。全文索引则更多地出现在对文本内容有搜索需求的场景。</p></blockquote><h3 id="7-布隆过滤器原理"><a href="#7-布隆过滤器原理" class="headerlink" title="7.布隆过滤器原理"></a>7.布隆过滤器原理</h3><blockquote><p>布隆过滤器（Bloom Filter）是一种空间效率极高的概率型数据结构，用于判断一个元素是否可能存在于一个集合中，但它不能百分之百保证判断的准确性，有可能会有误判（False Positive）的情况，但绝对不会漏判（False Negative），即如果布隆过滤器说一个元素不在集合中，则这个元素肯定不在集合内；如果它说可能在集合中，则元素可能真的在也可能不在集合中。</p><p>布隆过滤器的原理如下：</p><ol><li>初始化阶段： 创建一个固定长度的二进制向量（位数组），所有的位初始化为0。</li><li>插入元素： 当插入一个元素时，使用预先设定好的多个独立的哈希函数对元素进行运算，每个哈希函数都会映射到位数组的一个位置。对于每个哈希函数的输出，对应位数组的位置置为1。</li><li>查询元素： 当查询一个元素是否存在时，同样使用相同的哈希函数对该元素进行哈希运算，查看位数组中这些哈希函数对应的位置是否全为1。如果有一个位为0，则该元素肯定不在集合中；如果全为1，则认为元素可能在集合中（存在误判可能性）。</li></ol><p>由于哈希函数的碰撞，当多个不同的元素经过哈希运算后可能会落在位数组的同一位置，这就导致了误判的存在。随着越来越多的元素插入，误判率会逐渐增大。布隆过滤器的设计需要在误判率和存储空间之间做出折衷，通过调整位数组大小和哈希函数的数量来控制这种平衡。</p></blockquote><h3 id="8-布隆过滤器的误判率估算"><a href="#8-布隆过滤器的误判率估算" class="headerlink" title="8.布隆过滤器的误判率估算"></a>8.布隆过滤器的误判率估算</h3><blockquote><p>布隆过滤器的误判率（False Positive Rate，FPR）可以通过数学模型进行估算。误判率主要受到以下几个因素的影响：</p><ol><li><strong>位数组（Bit Array）的长度 m</strong>：布隆过滤器的基础是位数组，其长度m决定了可以存储的哈希值的空间。</li><li><strong>哈希函数的数量 k</strong>：用于映射元素到位数组的不同位置的独立且均匀分布的哈希函数个数。</li><li><strong>预计插入的元素数量 n</strong>：预估要加入布隆过滤器的元素总数。</li></ol><p>误判率的估算公式基于概率统计，其中一个重要公式是：</p><p>​                                                                    <strong>FPR</strong>≈(1−<em>e</em>−<em>kn</em>&#x2F;<em>m</em>)<strong>k</strong></p><p>随着m（位数组长度）的增加，或k（哈希函数数量）的增加，误判率会降低。但增大m或k也会相应地增加存储空间需求和计算成本。</p><p>为了在误判率和存储空间之间找到最佳平衡，可以反过来通过已知的误判率要求和预计插入元素数量n来计算所需的位数组长度m和哈希函数数量k。</p><p>实践中，布隆过滤器的大小和哈希函数的选择常常依据预设的误判率阈值和预期插入的元素数量进行设计和调整。在设计布隆过滤器时，通常会使用已有的公式和经验法则来确定适当的参数m和k。</p></blockquote><h3 id="9-string-和-stringbuffer，stringbuilder-区别"><a href="#9-string-和-stringbuffer，stringbuilder-区别" class="headerlink" title="9.string 和 stringbuffer，stringbuilder 区别"></a>9.string 和 stringbuffer，stringbuilder 区别</h3><blockquote><p><code>String</code>、<code>StringBuffer</code> 和 <code>StringBuilder</code> 都是Java中处理字符串的类，但它们在性能、线程安全性和可变性上有所区别：</p><ol><li><strong>String</strong><ul><li><code>String</code> 类型的字符串是不可变的（immutable）。一旦创建了一个字符串对象，其内容就不能被修改。这意味着每次对字符串的操作（如拼接、替换等）都会生成一个新的字符串对象。</li><li>因为不可变，所以 <code>String</code> 在多线程环境下是安全的，不需要同步。</li><li>由于频繁创建新的字符串对象，所以在处理大量字符串操作时，性能可能受到影响，特别是在循环中进行字符串连接时。</li></ul></li><li><strong>StringBuffer</strong><ul><li><code>StringBuffer</code> 类型的字符串是可变的（mutable），可以对原有的字符串对象进行修改，而不必创建新的对象。</li><li>它是线程安全的，其方法均是同步的（即添加了 <code>synchronized</code> 关键字），所以在多线程环境下，多个线程同时操作 <code>StringBuffer</code> 对象时不会出现问题。</li><li>由于线程安全性的保障，相较于 <code>StringBuilder</code>，在并发环境下 <code>StringBuffer</code> 的性能稍低。</li></ul></li><li><strong>StringBuilder</strong><ul><li><code>StringBuilder</code> 类型与 <code>StringBuffer</code> 类似，也是可变字符串，可以在原有对象基础上修改字符串内容，不会生成新的对象。</li><li>主要区别在于 <code>StringBuilder</code> 不是线程安全的，其方法没有进行同步处理，因此在单线程环境下，其性能通常优于 <code>StringBuffer</code>。</li><li>当字符串操作发生在单线程环境中，或者在知道不会有多线程同时修改字符串的情况下，推荐使用 <code>StringBuilder</code> 以获得更高的性能。</li></ul></li></ol><p>综上所述，<code>String</code> 适用于不需要修改的字符串常量，而 <code>StringBuffer</code> 和 <code>StringBuilder</code> 适用于需要进行大量字符串操作且要考虑线程安全或性能的场合。在不需要线程安全的场合，优选 <code>StringBuilder</code>，因为它没有线程同步的开销，效率更高。</p></blockquote><h3 id="10-说说对反射的理解，什么情况下会用反射"><a href="#10-说说对反射的理解，什么情况下会用反射" class="headerlink" title="10.说说对反射的理解，什么情况下会用反射"></a>10.说说对反射的理解，什么情况下会用反射</h3><blockquote><p>反射是编程中的一个高级概念，它允许程序在运行时检查和修改自身结构的能力，即在运行时能够发现并操作程序中的类、接口、字段和方法等元素。在Java中，反射机制提供了获取关于类的所有元数据的能力，包括但不限于类名、方法名、字段名、构造器等，并能够在运行时实例化对象、调用方法、更改字段值等，而这些操作在编译时通常是未知的。</p><p><strong>Java中的反射主要功能和应用包括：</strong></p><ol><li>动态加载类：根据字符串类名在运行时加载对应的类。</li><li>获取类信息：获取类的构造器、方法、字段、注解等详细信息。</li><li>动态创建对象：即使不知道具体的类型，也能创建类的实例。</li><li>动态调用方法：可以根据方法名和参数列表在运行时调用类的方法。</li><li>动态访问和修改字段：可以获取和修改类的私有或受保护的字段值。</li></ol><p><strong>何时使用反射：</strong></p><p>反射主要用于解决那些在编译期无法预知或灵活处理的问题，常见的应用场景包括：</p><ul><li><strong>框架设计</strong>：很多框架（如Spring、Hibernate等）为了实现依赖注入、对象生命周期管理等功能，都需要利用反射来处理类和对象的动态配置。</li><li><strong>通用工具类和库</strong>：比如序列化&#x2F;反序列化工具，需要通过反射来处理各种类型的对象。</li><li><strong>动态代理</strong>：Java中的动态代理也依赖于反射机制来创建代理类和调用目标方法。</li><li><strong>测试工具</strong>：自动化测试工具可能需要用到反射来验证私有方法的正确性，或者改变私有变量的状态来进行特定测试。</li><li><strong>适应性编程</strong>：当需要根据用户输入或配置文件来动态选择和执行类的功能时，反射机制可以派上用场。</li></ul><p>然而，需要注意的是，虽然反射功能强大，但它也有潜在的风险和劣势，如：</p><ul><li>性能损耗：反射操作比直接调用慢，因为涉及到额外的查找和安全性检查。</li><li>安全性问题：过度使用反射可能导致安全漏洞，特别是绕过访问控制机制。</li><li>代码可读性降低：反射代码往往较难理解和维护。</li></ul><p>因此，在实际开发中，除非确实有必要，否则应谨慎使用反射，并尽量避免在性能敏感或安全要求高的部分使用反射功能。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
            <tag> 喜马拉雅 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾迅后台一面</title>
      <link href="/post/48c2.html"/>
      <url>/post/48c2.html</url>
      
        <content type="html"><![CDATA[<h1 id="腾迅后台开发一面"><a href="#腾迅后台开发一面" class="headerlink" title="腾迅后台开发一面"></a>腾迅后台开发一面</h1><h3 id="1-讲一下TCP三次握手，为什么要三次，两次或者四次不行吗"><a href="#1-讲一下TCP三次握手，为什么要三次，两次或者四次不行吗" class="headerlink" title="1.讲一下TCP三次握手，为什么要三次，两次或者四次不行吗"></a>1.讲一下TCP三次握手，为什么要三次，两次或者四次不行吗</h3><blockquote><p>TCP建立连接时，通过三次握手能<strong>防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按需传输。</p><p>不使用<strong>两次握手</strong>和<strong>四次握手</strong>的原因：</p><ul><li>两次握手：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li><li>四次握手：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数；</li></ul></blockquote><h3 id="2-讲一下常见的针对TCP的网络攻击？如何应对SYN-flood攻击？"><a href="#2-讲一下常见的针对TCP的网络攻击？如何应对SYN-flood攻击？" class="headerlink" title="2.讲一下常见的针对TCP的网络攻击？如何应对SYN flood攻击？"></a>2.讲一下常见的针对TCP的网络攻击？如何应对SYN flood攻击？</h3><blockquote><p><strong>常见的针对TCP的网络攻击</strong></p><ul><li><strong>SYN Flood攻击</strong>：这是一种利用TCP协议握手过程中的缺陷进行的攻击。攻击者发送大量的TCP SYN请求到目标服务器，但在收到服务器的SYN+ACK响应后并不发送最后的ACK确认，导致服务器上留下大量等待完成的半开连接，耗尽服务器资源，使得正常的TCP连接无法建立。</li><li><strong>TCP回话劫持</strong>：这种攻击方式是通过窃取TCP会话中的序列号等信息，然后冒充合法用户接入到会话中。攻击者可以监听网络上的TCP会话，分析并预测序列号，然后发送伪造的数据包，中断或篡改原有的会话内容。</li><li><strong>TCP重置攻击</strong>：在这种攻击中，攻击者发送伪造的TCP RST（重置）数据包到目标主机，中断正常的TCP连接。由于TCP协议的设计，当接收到RST数据包时，连接的两端都会关闭连接，这使得攻击者可以成功地中断服务或进行拒绝服务攻击。</li></ul></blockquote><blockquote><p><strong>如何应对SYN flood攻击？</strong></p><ol><li>启用SYN Cookie技术：SYN Cookie是一种无状态的TCP连接技术，它通过计算一个独特的Cookie来验证TCP连接的合法性，而不需要在服务器上保存每个连接的状态信息。当服务器收到SYN请求时，它会计算一个Cookie并发送给客户端，客户端在后续的ACK报文中携带该Cookie，服务器通过验证Cookie的有效性来判断连接是否合法。这样可以有效减少服务器资源的消耗，并防止SYN Flood攻击导致的资源耗尽。</li><li>调整TCP协议栈参数：通过调整TCP协议栈的参数，可以优化服务器的性能和防御SYN Flood攻击。例如，可以减小SYN Timeout时间，使服务器更快地释放无效的链接请求；增大TCP连接的队列长度，提高服务器处理连接请求的能力；启用TCP Fast Open等特性，加快TCP连接的建立过程。</li><li>使用防火墙或入侵检测系统（IDS）：防火墙或IDS可以监控网络流量，并识别出异常的SYN请求流量。它们可以根据预设的规则对恶意流量进行过滤或限制，从而保护服务器免受SYN Flood攻击的侵害。</li></ol></blockquote><h3 id="3-讲一下TCP的TIME-WAIT状态，如果服务器中存在大量的这个状态应该怎么排查？"><a href="#3-讲一下TCP的TIME-WAIT状态，如果服务器中存在大量的这个状态应该怎么排查？" class="headerlink" title="3.讲一下TCP的TIME_WAIT状态，如果服务器中存在大量的这个状态应该怎么排查？"></a>3.讲一下TCP的TIME_WAIT状态，如果服务器中存在大量的这个状态应该怎么排查？</h3><blockquote><p><strong>介绍TIME_WAIT状态</strong>：当TCP连接的一方（通常是客户端）主动关闭连接时，会发送一个FIN包给对方，表示希望关闭连接。服务端通常会回一个ACK确认包。当服务端也完成发送后，会再次发送一个FIN包给客户端，此时客户端接收到FIN后会回复一个ACK给服务端，之后客户端会进入TIME_WAIT状态。在TIME_WAIT状态下，连接会保持一段时间（通常是2MSL，即最大报文段生存时间的两倍），以确保在网络中延迟的数据包能够被正确处理。</p><p><img src="https://cdn.jsdelivr.net/gh/mrxmxm/blog-img/blog-imgD2B5CA33BD970F64A6301FA75AE2EB22.png"></p></blockquote><blockquote><p><strong>如何排查TIME_WAIT</strong></p><ol><li><p><strong>确认TIME_WAIT状态的数量</strong>： 使用<code>netstat</code>命令来查看当前TCP连接的状态分布。例如，运行<code>netstat -nat | grep TIME_WAIT | wc -l</code>可以查看TIME_WAIT状态的连接数。</p></li><li><p><strong>查看系统TCP参数</strong>： 使用<code>sysctl -a | grep tcp</code>命令可以查看系统中与TCP相关的内核参数设置，特别关注<code>net.ipv4.tcp_tw_reuse</code>、<code>net.ipv4.tcp_tw_recycle</code>（在某些情况下可能不推荐启用）和<code>net.ipv4.tcp_fin_timeout</code>等参数的设置。</p></li><li><p><strong>分析网络连接和应用程序行为</strong>： 确定哪些应用程序或服务正在产生大量的TIME_WAIT连接。使用<code>netstat -natp</code>可以查看每个连接的进程ID和程序名称。</p></li><li><p><strong>检查网络问题和延迟</strong>： 网络问题或延迟可能导致连接不能正常关闭，从而产生大量的TIME_WAIT状态。使用网络诊断工具（如<code>ping</code>、<code>traceroute</code>等）来检查网络状况。</p></li></ol></blockquote><h3 id="4-如果项目中出现CPU占用过高的情况，该怎么排查和处理？"><a href="#4-如果项目中出现CPU占用过高的情况，该怎么排查和处理？" class="headerlink" title="4.如果项目中出现CPU占用过高的情况，该怎么排查和处理？"></a>4.如果项目中出现CPU占用过高的情况，该怎么排查和处理？</h3><blockquote><p>在Linux环境下，项目出现CPU占用过高的情况时，可以按照以下步骤进行排查和处理：</p><ol><li><strong>定位高CPU占用的进程</strong>：<ul><li>使用<code>top</code>命令查看系统中CPU占用率最高的进程。</li></ul></li><li><strong>分析进程中的线程</strong>：<ul><li>如果发现某个进程的CPU占用率特别高，可以使用<code>top -H -p [PID]</code>来查看该进程中各个线程的CPU占用情况。</li><li>找出占用CPU最高的线程ID。</li></ul></li><li><strong>转换线程ID为16进制</strong>：<ul><li>使用<code>printf &quot;%x\n&quot; [线程ID]</code>命令将线程ID转换为16进制格式。</li></ul></li><li><strong>获取线程堆栈信息</strong>：<ul><li>使用<code>jstack [进程PID] | grep [线程ID的16进制] -A 30</code>命令获取该线程的Java堆栈信息（如果是Java进程）。这可以帮助定位到具体的代码行或方法调用。</li><li>如果不是Java进程，可以使用<code>gdb</code>或其他相应的调试工具来获取线程的堆栈信息。</li></ul></li><li><strong>分析代码和日志</strong>：<ul><li>根据堆栈信息，检查相关的代码逻辑，看是否有死循环、资源泄露、复杂计算等导致CPU占用过高的问题。</li><li>同时检查应用程序的日志，看是否有异常或错误信息与高CPU占用相关。</li></ul></li><li><strong>处理措施</strong>：<ul><li>如果是代码问题，修复相应的bug或优化算法。</li><li>如果是配置问题，调整系统或应用程序的配置参数。</li><li>如果是资源不足，考虑增加硬件资源或优化资源分配。</li><li>如果是外部攻击，加强系统的安全防护措施。</li></ul></li></ol></blockquote><h3 id="5-介绍一下Linux常见命令？top命令具体是做什么的？"><a href="#5-介绍一下Linux常见命令？top命令具体是做什么的？" class="headerlink" title="5.介绍一下Linux常见命令？top命令具体是做什么的？"></a>5.介绍一下Linux常见命令？top命令具体是做什么的？</h3><blockquote><p>大家记忆一些，根据记忆回答就行，例如</p><ul><li><strong>chmod</strong>：更改文件或目录的权限。</li><li><strong>cat</strong>：查看文件内容。</li></ul></blockquote><blockquote><p><strong>top命令具体是做什么的？</strong> top命令，它是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况.该命令可以提供实时的对系统处理器的状态监视，它会显示系统中CPU最“敏感”的任务列表，并且可以按CPU使用、内存使用和执行时间对任务进行排序。</p></blockquote><h3 id="6-讲一下HashMap，为什么HashMap要引入红黑树？为什么树化的默认节点是8？如果不用红黑树如何处理过长的链表？"><a href="#6-讲一下HashMap，为什么HashMap要引入红黑树？为什么树化的默认节点是8？如果不用红黑树如何处理过长的链表？" class="headerlink" title="6.讲一下HashMap，为什么HashMap要引入红黑树？为什么树化的默认节点是8？如果不用红黑树如何处理过长的链表？"></a>6.讲一下HashMap，为什么HashMap要引入红黑树？为什么树化的默认节点是8？如果不用红黑树如何处理过长的链表？</h3><blockquote><p><strong>为什么HashMap要引入红黑树？</strong> 引入之前，当发生哈希冲突时，数据是以链表的形式进行存储的，如果冲突严重，链表就会过长，链表O（N）的复杂度性能太差。用红黑树期望是把复杂度降到<strong>O（log n）</strong></p></blockquote><blockquote><p>红黑树中的TreeNode是链表中的Node所占空间的2倍，虽然红黑树的查找效率为o(logN)，要优于链表的o(N)，但是当链表长度比较小的时候，即使全部遍历，时间复杂度也不会太高。固，要寻找一种时间和空间的平衡，即在链表长度达到一个阈值之后再转换为红黑树。 之所以是8，是因为Java的源码贡献者在进行大量实验发现，hash碰撞发生8次的概率已经降低到了0.00000006，几乎为不可能事件，如果真的碰撞发生了8次，那么这个时候说明由于元素本身和hash函数的原因，此时的链表性能已经已经很差了，操作的hash碰撞的可能性非常大了，后序可能还会继续发生hash碰撞。所以，在这种极端的情况下才会把链表转换为红黑树.</p></blockquote><blockquote><p><strong>如果不用红黑树如何处理过长的链表？</strong></p><ul><li><strong>使用其他数据结构</strong>:除了红黑树之外，还可以考虑使用其他数据结构来优化长链表的问题。例如，可以使用平衡树（如 AVL 树）、B树或B+树等。这些数据结构都可以在 O(log n) 的时间复杂度内完成查找、插入和删除操作.</li></ul></blockquote><h3 id="7-HashMap是线程安全的吗？如果不是那什么是？为什么ConcurrentHashMap是线程安全的？是如何实现线程安全的呢？"><a href="#7-HashMap是线程安全的吗？如果不是那什么是？为什么ConcurrentHashMap是线程安全的？是如何实现线程安全的呢？" class="headerlink" title="7.HashMap是线程安全的吗？如果不是那什么是？为什么ConcurrentHashMap是线程安全的？是如何实现线程安全的呢？"></a>7.HashMap是线程安全的吗？如果不是那什么是？为什么ConcurrentHashMap是线程安全的？是如何实现线程安全的呢？</h3><p><strong>解析：</strong>： 面试常见套路，先问HashMap 再 问 ConcurrentHashMap。 关于线程安全的实现，一般会结合JDK1.7和JDK1.8一起来回答，当然也可以只回答JDK1.8,如果面试官问到1.7你再回答。所以需要两个版本一起掌握.</p><blockquote><p>HashMap 不是现成安全的，需要保证现成安全的话，推荐使用ConcurrentHashMap。</p></blockquote><blockquote><p><strong>如何实现线程安全的？</strong></p><ul><li><strong>JDK 1.7</strong>中的<strong>ConcurrentHashMap</strong>通过分段锁（<strong>Segmentation</strong>）实现线程安全。它将整个哈希表分成多个段（<strong>Segment</strong>），每个段都是一个小的哈希表，并且拥有自己的锁。这样，多个线程可以并发地访问不同的段，从而减少了锁的竞争，提高了并发性能。</li><li><strong>JDK 1.8</strong>中的<strong>ConcurrentHashMap</strong>则采用了完全不同的设计。它摒弃了分段锁的概念，转而使用了一种更细粒度的锁策略，结合<strong>CAS（Compare-and-Swap）</strong>无锁算法来实现线程安全。在<strong>JDK 1.8</strong>中，<strong>ConcurrentHashMap</strong>将整个哈希表看作一个整体，不再进行分段。而是通过<strong>数组+链表+红黑树</strong>的结构来存储数据，并使用<strong>Synchronized和CAS</strong>来协调并发访问。</li></ul></blockquote><h3 id="8-介绍一下Base64编码的原理，为什么Base64编码会使数据体积变大33-？"><a href="#8-介绍一下Base64编码的原理，为什么Base64编码会使数据体积变大33-？" class="headerlink" title="8.介绍一下Base64编码的原理，为什么Base64编码会使数据体积变大33%？"></a>8.介绍一下Base64编码的原理，为什么Base64编码会使数据体积变大33%？</h3><blockquote><p><strong>Base64编码是</strong>:一种基于64个可打印字符来表示二进制数据的方法。其编码原理是将一个8位字节序列拆散为6位的片段，并为每个6位的片段分配一个字符，这64个字符包括小写字母a-z、大写字母A-Z、数字0-9、符号”+”和”&#x2F;“。实际上，还有一个垫字符”&#x3D;”，用于编码后的数据长度不是4的倍数时进行填充，因此严格来说有65个字符。</p></blockquote><blockquote><p><strong>Base64编码会使数据体积变大33%左右的原因</strong>:在于其编码方式。原始的二进制数据是按照8位一个字节进行存储的，而Base64编码将其拆分为6位一组，并用一个字符表示。这样，原本3个字节（24位）的数据被编码成了4个字符（每个字符8位，共32位）。因此，编码后的数据长度大约是原始数据长度的4&#x2F;3，即增加了约33%。</p></blockquote><h3 id="9-为什么Redis-Pub-Sub比Kafka更快一些？二者之间如何选取？"><a href="#9-为什么Redis-Pub-Sub比Kafka更快一些？二者之间如何选取？" class="headerlink" title="9.为什么Redis Pub&#x2F;Sub比Kafka更快一些？二者之间如何选取？"></a>9.为什么Redis Pub&#x2F;Sub比Kafka更快一些？二者之间如何选取？</h3><p><strong>解析：</strong>频率一般，推荐掌握。重在理解redis本身特点和Kafka的实现原理。然后推导回答，不要背。</p><blockquote><p><strong>为什么Redis Pub&#x2F;Sub比Kafka更快一些？</strong> Redis是一个内存数据库，其Pub&#x2F;Sub功能将消息保存在内存中。由于内存访问速度通常远快于磁盘访问速度，因此Redis在处理实时性较高的消息推送时具有优势。此外，Redis的Pub&#x2F;Sub模型相对简单，使得它在处理发布和订阅操作时的开销较小。 然而，Kafka是一个完整的系统，提供了高吞吐量、分布式的提交日志。它旨在处理大规模数据流，具有强大的持久化能力和容错性。Kafka的分布式架构和分区机制使得它能够在多个消费者之间实现负载均衡，从而提高整体处理能力。</p></blockquote><blockquote><p><strong>二者之间如何选取？</strong></p><p><strong>Redis PUB&#x2F;SUB使用场景：</strong></p><ol><li>消息持久性需求不高</li><li>吞吐量要求不高</li><li>可以忍受数据丢失</li><li>数据量不大</li></ol><p><strong>Kafka使用场景：</strong>(上面以外的其他场景)</p><ol><li>高可靠性</li><li>高吞吐量</li><li>持久性高</li><li>多样化的消费处理模型</li></ol></blockquote><h3 id="9-Kafka是如何做到数据持久化的？"><a href="#9-Kafka是如何做到数据持久化的？" class="headerlink" title="9.Kafka是如何做到数据持久化的？"></a>9.Kafka是如何做到数据持久化的？</h3><p><strong>解析：</strong>Kafka相关高频面试题，Kafka重要原理知识点之一，推荐掌握</p><blockquote><ol><li><p>Kafka把Topic中一个Partition大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完成的文件，减少磁盘占用</p></li><li><p>通过索引信息可以快速定位Message和确定response的最大大小</p></li><li><p>通过将索引元数据全部映射到 memory，可以避免 Segment 文件的磁盘I&#x2F;O操作</p></li><li><p>通过索引文件稀疏存储，可以大幅降低索引文件元数据占用空间大小</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 腾讯 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客部署</title>
      <link href="/post/9365.html"/>
      <url>/post/9365.html</url>
      
        <content type="html"><![CDATA[<h2 id="测试是否能否显示文字"><a href="#测试是否能否显示文字" class="headerlink" title="测试是否能否显示文字"></a>测试是否能否显示文字</h2><p><img src="https://cdn.jsdelivr.net/gh/tianzhijiaozi123/blog-img/blog-img89b21dc8-9be9-466e-a4b0-5759a7897f76-1709370908863.png"></p><h4 id="兔子和小狗"><a href="#兔子和小狗" class="headerlink" title="兔子和小狗"></a>兔子和小狗</h4><p><img src="https://cdn.jsdelivr.net/gh/tianzhijiaozi123/blog-img/blog-imgdog-rabbit.png"></p><h2 id="部署流程"><a href="#部署流程" class="headerlink" title="部署流程"></a>部署流程</h2><h3 id="文章发布"><a href="#文章发布" class="headerlink" title="文章发布"></a>文章发布</h3><blockquote><p>进入 <strong>F:\Blog\source_posts</strong> 文件夹，然后右键 <strong>git bash</strong> ，再输入命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npx hexo new post &quot;新建博客文件名&quot;</span><br></pre></td></tr></table></figure><p>之后就在该文件夹中生成一个新的md文件，就可以在该文件中书写博客了，每次写完博客要上传部署时，输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npx hexo cl   #清空缓存</span><br><span class="line">npx hexo g    #上传静态文件</span><br><span class="line">npx hexo s    #进行保存，然后就可以在本地访问了</span><br><span class="line"># 最后就是上传部署</span><br><span class="line">npx hexo d</span><br></pre></td></tr></table></figure></blockquote><h3 id="更新配置"><a href="#更新配置" class="headerlink" title="更新配置"></a>更新配置</h3><p>更新hexo配置一般在**_config.yml<strong>文件中，更新</strong>butterfly<strong>主题配置在</strong>_config.butterfly.yml**文件中</p><p>主题中相关图片背景的地址放在<strong>F:\Blog\themes\butterfly\source\img</strong>文件夹下，在该文件夹下进行图片更换</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
            <tag> Hexo </tag>
            
            <tag> 主题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/3eeb.html"/>
      <url>/post/3eeb.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p>上传新的图片</p><p><img src="https://st.tencent-cloud.com/qb/tool/images/fa45a96f-cad1-4a5d-a426-678e85662f57.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
            <tag> 主题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
