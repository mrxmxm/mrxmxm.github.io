<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java面经-3</title>
      <link href="/post/8943.html"/>
      <url>/post/8943.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>腾迅后台一面</title>
      <link href="/post/48c2.html"/>
      <url>/post/48c2.html</url>
      
        <content type="html"><![CDATA[<h1 id="腾迅后台开发一面"><a href="#腾迅后台开发一面" class="headerlink" title="腾迅后台开发一面"></a>腾迅后台开发一面</h1><h3 id="1-讲一下TCP三次握手，为什么要三次，两次或者四次不行吗"><a href="#1-讲一下TCP三次握手，为什么要三次，两次或者四次不行吗" class="headerlink" title="1.讲一下TCP三次握手，为什么要三次，两次或者四次不行吗"></a>1.讲一下TCP三次握手，为什么要三次，两次或者四次不行吗</h3><blockquote><p>TCP建立连接时，通过三次握手能<strong>防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按需传输。</p><p>不使用<strong>两次握手</strong>和<strong>四次握手</strong>的原因：</p><ul><li>两次握手：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li><li>四次握手：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数；</li></ul></blockquote><h3 id="2-讲一下常见的针对TCP的网络攻击？如何应对SYN-flood攻击？"><a href="#2-讲一下常见的针对TCP的网络攻击？如何应对SYN-flood攻击？" class="headerlink" title="2.讲一下常见的针对TCP的网络攻击？如何应对SYN flood攻击？"></a>2.讲一下常见的针对TCP的网络攻击？如何应对SYN flood攻击？</h3><blockquote><p><strong>常见的针对TCP的网络攻击</strong></p><ul><li><strong>SYN Flood攻击</strong>：这是一种利用TCP协议握手过程中的缺陷进行的攻击。攻击者发送大量的TCP SYN请求到目标服务器，但在收到服务器的SYN+ACK响应后并不发送最后的ACK确认，导致服务器上留下大量等待完成的半开连接，耗尽服务器资源，使得正常的TCP连接无法建立。</li><li><strong>TCP回话劫持</strong>：这种攻击方式是通过窃取TCP会话中的序列号等信息，然后冒充合法用户接入到会话中。攻击者可以监听网络上的TCP会话，分析并预测序列号，然后发送伪造的数据包，中断或篡改原有的会话内容。</li><li><strong>TCP重置攻击</strong>：在这种攻击中，攻击者发送伪造的TCP RST（重置）数据包到目标主机，中断正常的TCP连接。由于TCP协议的设计，当接收到RST数据包时，连接的两端都会关闭连接，这使得攻击者可以成功地中断服务或进行拒绝服务攻击。</li></ul></blockquote><blockquote><p><strong>如何应对SYN flood攻击？</strong></p><ol><li>启用SYN Cookie技术：SYN Cookie是一种无状态的TCP连接技术，它通过计算一个独特的Cookie来验证TCP连接的合法性，而不需要在服务器上保存每个连接的状态信息。当服务器收到SYN请求时，它会计算一个Cookie并发送给客户端，客户端在后续的ACK报文中携带该Cookie，服务器通过验证Cookie的有效性来判断连接是否合法。这样可以有效减少服务器资源的消耗，并防止SYN Flood攻击导致的资源耗尽。</li><li>调整TCP协议栈参数：通过调整TCP协议栈的参数，可以优化服务器的性能和防御SYN Flood攻击。例如，可以减小SYN Timeout时间，使服务器更快地释放无效的链接请求；增大TCP连接的队列长度，提高服务器处理连接请求的能力；启用TCP Fast Open等特性，加快TCP连接的建立过程。</li><li>使用防火墙或入侵检测系统（IDS）：防火墙或IDS可以监控网络流量，并识别出异常的SYN请求流量。它们可以根据预设的规则对恶意流量进行过滤或限制，从而保护服务器免受SYN Flood攻击的侵害。</li></ol></blockquote><h3 id="3-讲一下TCP的TIME-WAIT状态，如果服务器中存在大量的这个状态应该怎么排查？"><a href="#3-讲一下TCP的TIME-WAIT状态，如果服务器中存在大量的这个状态应该怎么排查？" class="headerlink" title="3.讲一下TCP的TIME_WAIT状态，如果服务器中存在大量的这个状态应该怎么排查？"></a>3.讲一下TCP的TIME_WAIT状态，如果服务器中存在大量的这个状态应该怎么排查？</h3><blockquote><p><strong>介绍TIME_WAIT状态</strong>：当TCP连接的一方（通常是客户端）主动关闭连接时，会发送一个FIN包给对方，表示希望关闭连接。服务端通常会回一个ACK确认包。当服务端也完成发送后，会再次发送一个FIN包给客户端，此时客户端接收到FIN后会回复一个ACK给服务端，之后客户端会进入TIME_WAIT状态。在TIME_WAIT状态下，连接会保持一段时间（通常是2MSL，即最大报文段生存时间的两倍），以确保在网络中延迟的数据包能够被正确处理。</p><p><img src="https://cdn.jsdelivr.net/gh/mrxmxm/blog-img/blog-imgD2B5CA33BD970F64A6301FA75AE2EB22.png"></p></blockquote><blockquote><p><strong>如何排查TIME_WAIT</strong></p><ol><li><p><strong>确认TIME_WAIT状态的数量</strong>： 使用<code>netstat</code>命令来查看当前TCP连接的状态分布。例如，运行<code>netstat -nat | grep TIME_WAIT | wc -l</code>可以查看TIME_WAIT状态的连接数。</p></li><li><p><strong>查看系统TCP参数</strong>： 使用<code>sysctl -a | grep tcp</code>命令可以查看系统中与TCP相关的内核参数设置，特别关注<code>net.ipv4.tcp_tw_reuse</code>、<code>net.ipv4.tcp_tw_recycle</code>（在某些情况下可能不推荐启用）和<code>net.ipv4.tcp_fin_timeout</code>等参数的设置。</p></li><li><p><strong>分析网络连接和应用程序行为</strong>： 确定哪些应用程序或服务正在产生大量的TIME_WAIT连接。使用<code>netstat -natp</code>可以查看每个连接的进程ID和程序名称。</p></li><li><p><strong>检查网络问题和延迟</strong>： 网络问题或延迟可能导致连接不能正常关闭，从而产生大量的TIME_WAIT状态。使用网络诊断工具（如<code>ping</code>、<code>traceroute</code>等）来检查网络状况。</p></li></ol></blockquote><h3 id="4-如果项目中出现CPU占用过高的情况，该怎么排查和处理？"><a href="#4-如果项目中出现CPU占用过高的情况，该怎么排查和处理？" class="headerlink" title="4.如果项目中出现CPU占用过高的情况，该怎么排查和处理？"></a>4.如果项目中出现CPU占用过高的情况，该怎么排查和处理？</h3><blockquote><p>在Linux环境下，项目出现CPU占用过高的情况时，可以按照以下步骤进行排查和处理：</p><ol><li><strong>定位高CPU占用的进程</strong>：<ul><li>使用<code>top</code>命令查看系统中CPU占用率最高的进程。</li></ul></li><li><strong>分析进程中的线程</strong>：<ul><li>如果发现某个进程的CPU占用率特别高，可以使用<code>top -H -p [PID]</code>来查看该进程中各个线程的CPU占用情况。</li><li>找出占用CPU最高的线程ID。</li></ul></li><li><strong>转换线程ID为16进制</strong>：<ul><li>使用<code>printf &quot;%x\n&quot; [线程ID]</code>命令将线程ID转换为16进制格式。</li></ul></li><li><strong>获取线程堆栈信息</strong>：<ul><li>使用<code>jstack [进程PID] | grep [线程ID的16进制] -A 30</code>命令获取该线程的Java堆栈信息（如果是Java进程）。这可以帮助定位到具体的代码行或方法调用。</li><li>如果不是Java进程，可以使用<code>gdb</code>或其他相应的调试工具来获取线程的堆栈信息。</li></ul></li><li><strong>分析代码和日志</strong>：<ul><li>根据堆栈信息，检查相关的代码逻辑，看是否有死循环、资源泄露、复杂计算等导致CPU占用过高的问题。</li><li>同时检查应用程序的日志，看是否有异常或错误信息与高CPU占用相关。</li></ul></li><li><strong>处理措施</strong>：<ul><li>如果是代码问题，修复相应的bug或优化算法。</li><li>如果是配置问题，调整系统或应用程序的配置参数。</li><li>如果是资源不足，考虑增加硬件资源或优化资源分配。</li><li>如果是外部攻击，加强系统的安全防护措施。</li></ul></li></ol></blockquote><h3 id="5-介绍一下Linux常见命令？top命令具体是做什么的？"><a href="#5-介绍一下Linux常见命令？top命令具体是做什么的？" class="headerlink" title="5.介绍一下Linux常见命令？top命令具体是做什么的？"></a>5.介绍一下Linux常见命令？top命令具体是做什么的？</h3><blockquote><p>大家记忆一些，根据记忆回答就行，例如</p><ul><li><strong>chmod</strong>：更改文件或目录的权限。</li><li><strong>cat</strong>：查看文件内容。</li></ul></blockquote><blockquote><p><strong>top命令具体是做什么的？</strong> top命令，它是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况.该命令可以提供实时的对系统处理器的状态监视，它会显示系统中CPU最“敏感”的任务列表，并且可以按CPU使用、内存使用和执行时间对任务进行排序。</p></blockquote><h3 id="6-讲一下HashMap，为什么HashMap要引入红黑树？为什么树化的默认节点是8？如果不用红黑树如何处理过长的链表？"><a href="#6-讲一下HashMap，为什么HashMap要引入红黑树？为什么树化的默认节点是8？如果不用红黑树如何处理过长的链表？" class="headerlink" title="6.讲一下HashMap，为什么HashMap要引入红黑树？为什么树化的默认节点是8？如果不用红黑树如何处理过长的链表？"></a>6.讲一下HashMap，为什么HashMap要引入红黑树？为什么树化的默认节点是8？如果不用红黑树如何处理过长的链表？</h3><blockquote><p><strong>为什么HashMap要引入红黑树？</strong> 引入之前，当发生哈希冲突时，数据是以链表的形式进行存储的，如果冲突严重，链表就会过长，链表O（N）的复杂度性能太差。用红黑树期望是把复杂度降到<strong>O（log n）</strong></p></blockquote><blockquote><p>红黑树中的TreeNode是链表中的Node所占空间的2倍，虽然红黑树的查找效率为o(logN)，要优于链表的o(N)，但是当链表长度比较小的时候，即使全部遍历，时间复杂度也不会太高。固，要寻找一种时间和空间的平衡，即在链表长度达到一个阈值之后再转换为红黑树。 之所以是8，是因为Java的源码贡献者在进行大量实验发现，hash碰撞发生8次的概率已经降低到了0.00000006，几乎为不可能事件，如果真的碰撞发生了8次，那么这个时候说明由于元素本身和hash函数的原因，此时的链表性能已经已经很差了，操作的hash碰撞的可能性非常大了，后序可能还会继续发生hash碰撞。所以，在这种极端的情况下才会把链表转换为红黑树.</p></blockquote><blockquote><p><strong>如果不用红黑树如何处理过长的链表？</strong></p><ul><li><strong>使用其他数据结构</strong>:除了红黑树之外，还可以考虑使用其他数据结构来优化长链表的问题。例如，可以使用平衡树（如 AVL 树）、B树或B+树等。这些数据结构都可以在 O(log n) 的时间复杂度内完成查找、插入和删除操作.</li></ul></blockquote><h3 id="7-HashMap是线程安全的吗？如果不是那什么是？为什么ConcurrentHashMap是线程安全的？是如何实现线程安全的呢？"><a href="#7-HashMap是线程安全的吗？如果不是那什么是？为什么ConcurrentHashMap是线程安全的？是如何实现线程安全的呢？" class="headerlink" title="7.HashMap是线程安全的吗？如果不是那什么是？为什么ConcurrentHashMap是线程安全的？是如何实现线程安全的呢？"></a>7.HashMap是线程安全的吗？如果不是那什么是？为什么ConcurrentHashMap是线程安全的？是如何实现线程安全的呢？</h3><p><strong>解析：</strong>： 面试常见套路，先问HashMap 再 问 ConcurrentHashMap。 关于线程安全的实现，一般会结合JDK1.7和JDK1.8一起来回答，当然也可以只回答JDK1.8,如果面试官问到1.7你再回答。所以需要两个版本一起掌握.</p><blockquote><p>HashMap 不是现成安全的，需要保证现成安全的话，推荐使用ConcurrentHashMap。</p></blockquote><blockquote><p><strong>如何实现线程安全的？</strong></p><ul><li><strong>JDK 1.7</strong>中的<strong>ConcurrentHashMap</strong>通过分段锁（<strong>Segmentation</strong>）实现线程安全。它将整个哈希表分成多个段（<strong>Segment</strong>），每个段都是一个小的哈希表，并且拥有自己的锁。这样，多个线程可以并发地访问不同的段，从而减少了锁的竞争，提高了并发性能。</li><li><strong>JDK 1.8</strong>中的<strong>ConcurrentHashMap</strong>则采用了完全不同的设计。它摒弃了分段锁的概念，转而使用了一种更细粒度的锁策略，结合<strong>CAS（Compare-and-Swap）</strong>无锁算法来实现线程安全。在<strong>JDK 1.8</strong>中，<strong>ConcurrentHashMap</strong>将整个哈希表看作一个整体，不再进行分段。而是通过<strong>数组+链表+红黑树</strong>的结构来存储数据，并使用<strong>Synchronized和CAS</strong>来协调并发访问。</li></ul></blockquote><h3 id="8-介绍一下Base64编码的原理，为什么Base64编码会使数据体积变大33-？"><a href="#8-介绍一下Base64编码的原理，为什么Base64编码会使数据体积变大33-？" class="headerlink" title="8.介绍一下Base64编码的原理，为什么Base64编码会使数据体积变大33%？"></a>8.介绍一下Base64编码的原理，为什么Base64编码会使数据体积变大33%？</h3><blockquote><p><strong>Base64编码是</strong>:一种基于64个可打印字符来表示二进制数据的方法。其编码原理是将一个8位字节序列拆散为6位的片段，并为每个6位的片段分配一个字符，这64个字符包括小写字母a-z、大写字母A-Z、数字0-9、符号”+”和”&#x2F;“。实际上，还有一个垫字符”&#x3D;”，用于编码后的数据长度不是4的倍数时进行填充，因此严格来说有65个字符。</p></blockquote><blockquote><p><strong>Base64编码会使数据体积变大33%左右的原因</strong>:在于其编码方式。原始的二进制数据是按照8位一个字节进行存储的，而Base64编码将其拆分为6位一组，并用一个字符表示。这样，原本3个字节（24位）的数据被编码成了4个字符（每个字符8位，共32位）。因此，编码后的数据长度大约是原始数据长度的4&#x2F;3，即增加了约33%。</p></blockquote><h3 id="9-为什么Redis-Pub-Sub比Kafka更快一些？二者之间如何选取？"><a href="#9-为什么Redis-Pub-Sub比Kafka更快一些？二者之间如何选取？" class="headerlink" title="9.为什么Redis Pub&#x2F;Sub比Kafka更快一些？二者之间如何选取？"></a>9.为什么Redis Pub&#x2F;Sub比Kafka更快一些？二者之间如何选取？</h3><p><strong>解析：</strong>频率一般，推荐掌握。重在理解redis本身特点和Kafka的实现原理。然后推导回答，不要背。</p><blockquote><p><strong>为什么Redis Pub&#x2F;Sub比Kafka更快一些？</strong> Redis是一个内存数据库，其Pub&#x2F;Sub功能将消息保存在内存中。由于内存访问速度通常远快于磁盘访问速度，因此Redis在处理实时性较高的消息推送时具有优势。此外，Redis的Pub&#x2F;Sub模型相对简单，使得它在处理发布和订阅操作时的开销较小。 然而，Kafka是一个完整的系统，提供了高吞吐量、分布式的提交日志。它旨在处理大规模数据流，具有强大的持久化能力和容错性。Kafka的分布式架构和分区机制使得它能够在多个消费者之间实现负载均衡，从而提高整体处理能力。</p></blockquote><blockquote><p><strong>二者之间如何选取？</strong></p><p><strong>Redis PUB&#x2F;SUB使用场景：</strong></p><ol><li>消息持久性需求不高</li><li>吞吐量要求不高</li><li>可以忍受数据丢失</li><li>数据量不大</li></ol><p><strong>Kafka使用场景：</strong>(上面以外的其他场景)</p><ol><li>高可靠性</li><li>高吞吐量</li><li>持久性高</li><li>多样化的消费处理模型</li></ol></blockquote><h3 id="9-Kafka是如何做到数据持久化的？"><a href="#9-Kafka是如何做到数据持久化的？" class="headerlink" title="9.Kafka是如何做到数据持久化的？"></a>9.Kafka是如何做到数据持久化的？</h3><p><strong>解析：</strong>Kafka相关高频面试题，Kafka重要原理知识点之一，推荐掌握</p><blockquote><ol><li><p>Kafka把Topic中一个Partition大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完成的文件，减少磁盘占用</p></li><li><p>通过索引信息可以快速定位Message和确定response的最大大小</p></li><li><p>通过将索引元数据全部映射到 memory，可以避免 Segment 文件的磁盘I&#x2F;O操作</p></li><li><p>通过索引文件稀疏存储，可以大幅降低索引文件元数据占用空间大小</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 腾讯 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客部署</title>
      <link href="/post/9365.html"/>
      <url>/post/9365.html</url>
      
        <content type="html"><![CDATA[<h2 id="测试是否能否显示文字"><a href="#测试是否能否显示文字" class="headerlink" title="测试是否能否显示文字"></a>测试是否能否显示文字</h2><p><img src="https://cdn.jsdelivr.net/gh/tianzhijiaozi123/blog-img/blog-img89b21dc8-9be9-466e-a4b0-5759a7897f76-1709370908863.png"></p><h4 id="兔子和小狗"><a href="#兔子和小狗" class="headerlink" title="兔子和小狗"></a>兔子和小狗</h4><p><img src="https://cdn.jsdelivr.net/gh/tianzhijiaozi123/blog-img/blog-imgdog-rabbit.png"></p><h2 id="部署流程"><a href="#部署流程" class="headerlink" title="部署流程"></a>部署流程</h2><h3 id="文章发布"><a href="#文章发布" class="headerlink" title="文章发布"></a>文章发布</h3><blockquote><p>进入 <strong>F:\Blog\source_posts</strong> 文件夹，然后右键 <strong>git bash</strong> ，再输入命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npx hexo new post &quot;新建博客文件名&quot;</span><br></pre></td></tr></table></figure><p>之后就在该文件夹中生成一个新的md文件，就可以在该文件中书写博客了，每次写完博客要上传部署时，输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npx hexo cl   #清空缓存</span><br><span class="line">npx hexo g    #上传静态文件</span><br><span class="line">npx hexo s    #进行保存，然后就可以在本地访问了</span><br><span class="line"># 最后就是上传部署</span><br><span class="line">npx hexo d</span><br></pre></td></tr></table></figure></blockquote><h3 id="更新配置"><a href="#更新配置" class="headerlink" title="更新配置"></a>更新配置</h3><p>更新hexo配置一般在**_config.yml<strong>文件中，更新</strong>butterfly<strong>主题配置在</strong>_config.butterfly.yml**文件中</p><p>主题中相关图片背景的地址放在<strong>F:\Blog\themes\butterfly\source\img</strong>文件夹下，在该文件夹下进行图片更换</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
            <tag> 主题 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/3eeb.html"/>
      <url>/post/3eeb.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p>上传新的图片</p><p><img src="https://st.tencent-cloud.com/qb/tool/images/fa45a96f-cad1-4a5d-a426-678e85662f57.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
            <tag> 主题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
